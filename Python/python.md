
<a name="pzsuh"></a>
## python的装饰器
**答：**装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，它接受一个函数作为参数，并返回一个函数，利用python的@语法来放置

装饰器本质上是一个Python函数，它**可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象**。它经常用于有切面需求的**场景**，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

<a name="bXbVd"></a>
### python 装饰器@staticmethod和@classmethod区别和使用
使用原因：使用@staticmethod或@classmethod，**就可以不需要实例化，直接类名.方法名()来调用**。这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。<br />@staticmethod或@classmethod的区别

- 类的普通方法，第一个参数需要self参数表示自身。
- @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
- @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。

具体解释：

- 实例方法 

    定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；<br />    调用：只能由实例对象调用。

- 类方法 `@classmethod`

    定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；<br />    调用：实例对象和类对象都可以调用。

- 静态方法 `@staticmethod`

    定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；<br />    调用：实例对象和类对象都可以调用。

<a name="EEpmr"></a>
### @property
用于为类属性创建只读属性。它允许你**将一个方法定义为类的属性**，**这样你可以像访问普通属性一样使用点表示法来访问它**，但实际上它会调用方法来获取属性的值。
<a name="zHUIt"></a>
### 装饰器的作用域？
装饰器的作用域是在被装饰的函数定义之后，以及在装饰器函数定义之后，但在装饰器应用之前。<br />具体来说，装饰器的作用域可以分为以下两个阶段：

- **装饰器函数**的作用域：

**装饰器函数**的作用域是在它的定义之后，直到装饰器应用之前。在装饰器函数的作用域内，你可以通过闭包的方式访问外部函数的局部变量，从而实现对被装饰函数的额外功能添加。装饰器函数可以接受一个函数作为参数，并返回一个新的函数（通常是内部函数），该内部函数用于装饰输入的函数。

- **被装饰函数**的作用域：

**被装饰函数**的作用域是在它的定义之后，包括装饰器应用之后。在被装饰函数的作用域内，你可以使用装饰器应用后的函数来调用被装饰函数，并使用其扩展后的功能。在这个阶段，被装饰函数已经被装饰器函数包裹并添加了额外的功能。<br />示例说明装饰器的作用域：
```python
def my_decorator(func):
    print("Decorator function is defined")

    def wrapper():
        print("Before function execution")
        func()
        print("After function execution")
	# 注意！！哪怕是在这里的内容，也会跟第一个print一起作用，作用域相同。
    # 也就是只要是my_decorator中的除了嵌套的内部函数，都会在定义的时候执行。
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

print("After decorator application")

say_hello()
```
输出：
```python
Decorator function is defined
After decorator application
Before function execution
Hello!
After function execution
```
可以看到装饰器函数my_decorator在定义时就执行了打印语句，说明装饰器函数的作用域在定义时已经开始。然后，在装饰器应用之后，我们再次打印了"After decorator application"，表明被装饰函数say_hello的定义也在装饰器应用后继续执行。
<a name="yRfZA"></a>
## 写个python装饰器：测程序运行时间
```python
import time


def test_running_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        ans = func(*args, **kwargs)
        end_time = time.time()
        print('time cost: {}s'.format(end_time - start_time))
        return ans

    return wrapper


@test_running_time
def func1():
    print("hello, world!")

func1()

```
<a name="D0tmw"></a>
## python装饰器实现重试功能代码实现
```python

def retry_func(try_count=10):
    def _wrapper(func):
        def wrapper(*args, **kwargs):
            cnt = try_count
            while cnt:
                try:
                    ans = func(*args, **kwargs)
                except Exception as e:
                    print(e)
                    print('Retrying {}..'.format(cnt))
                else:
                    return ans
                cnt -= 1
        return wrapper
    return _wrapper


@retry_func(try_count=10)
def func1():
    z = 1/0
    print('Done!')
    pass


if __name__ == '__main__':

    func1()

```

<a name="e9Fo1"></a>
## python的迭代器
**什么是迭代器？**<br />**答：一个实现了__iter__方法和__next__方法的对象，就是迭代器。__iter__方法返回自身，__next__方法返回下一个位置的数据。使用iter()和next()会调用迭代器的__iter__方法和__next__方法。**<br />**定义：**迭代器是一个可以记住遍历位置的**对象**。迭代器对象从第一个元素开始访问，直到所有的元素被访问结束。迭代器只能往前不会后退。<br />实际上，在使用 next()函数的时候，调用的就是迭代器对象的 **next** 方法。<br />所以想要构造一个迭代器，就要实现它的 __next__方法。<br />但这还不够，**python要求迭代器本身也是可迭代的**，**所以我们还要为迭代器实现 __iter__方法**，而 **__iter__方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的 __iter__方法返回自身即可。**<br />**一个实现了__iter__方法和__next__方法的对象，就是迭代器。**<br />可以使用 isinstance() 判断一个对象是否是Iterator对象
```python
from collections.abc import Iterable
from collections.abc import Iterator
```
自定义迭代器：
```python
class MyList:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < len(self.data):
            ans = self.data[self.index]
            self.index += 1
            return ans
        else:
            raise StopIteration


if __name__ == '__main__':
    a = [1, 2, 3]
    lst = MyList(a)
    for num in lst:
        print(num)
```
输出：
```python
1
2
3
```
<a name="qCfa6"></a>
## python的生成器
<a name="StjKm"></a>
### 什么是生成器？
**答**：**生成器（Generator）是一种特殊的迭代器，**它是**通过函数来创建的**，**使用yield关键字来产生元素，而不是使用return关键字。**生成器函数在调用时并不立即执行，而是返回一个生成器对象，取值时，通过next()方法或for循环操作获取生成器对象中的值，并将函数的状态保存，以便在下次调用时从上次离开的地方继续执行。
<a name="hK9ug"></a>
### 特点

- 如果所要的序列的元素可以按照某种算法推算出来，可以采用迭代器一边循环一边计算的机制，这样就**不必创建完整的序列，从而节省大量的空间。**
- 协程是基于生成器实现的。
<a name="JxLmV"></a>
### 生成器的优点

1. **节约内存**。python在**使用生成器在需要的时候才产生结果，而不是立即产生结果**。这样在需要的时候才去调用结果，而不是将结果提前存储起来要**节约内存。**
2. 迭代到下一次的调用时，所使用的参数都是第一次所保留下的。
<a name="N9yBj"></a>
### 生成器的创建方式

1. **生成器表达式**
```python
my_generator = (x**2 for x in range(10))
```

2. **生成器函数**

生成器函数是一个普通函数，但使用yield关键字来产生值。当调用生成器函数时，它不会立即执行，而是返回一个生成器对象。

<a name="OvqYi"></a>
## 装饰器、迭代器、生成器含义

装饰器、迭代器和生成器都是Python中的重要概念，它们在不同的场景下有不同的含义和用途。

1.  **装饰器（Decorator）：** 
   - 含义：**装饰器是**一种特殊的**函数**，用于扩展或修改其他函数的功能。装饰器接受一个函数作为输入，并返回一个新的函数，用于装饰输入的函数。装饰器通常用于在不改变原函数定义的情况下，为函数添加额外的功能，比如日志记录、缓存、权限验证等。
   - 用途：装饰器在Python中常用于实现面向切面编程，解耦和分离关注点，提供更加灵活和可复用的代码结构。
2.  **迭代器（Iterator）：** 
   - 含义：**迭代器是**一种**对象**，用于**遍历可迭代对象（如列表、元组、字典等）中的元素**。**迭代器实现了两个方法：**`**__iter__()**`**和**`**__next__()**`。`__iter__()`方法返回迭代器对象本身，而`__next__()`方法返回可迭代对象中的下一个元素，当没有元素可迭代时，抛出`StopIteration`异常。
   - 用途：迭代器提供了一种统一的方式来遍历各种容器类型的元素，使得代码更加简洁和可读。
3.  **生成器（Generator）：** 
   - 含义：**生成器是**一种特殊的**迭代器**，它是通过函数来创建的，使用`yield`关键字来产生元素，而不是使用`return`关键字。当调用生成器函数时，它并不执行函数体内的代码，而是返回一个生成器对象。每次调用生成器的`__next__()`方法时，函数会从上次离开的地方继续执行，直到遇到`yield`语句，产生一个元素并返回给调用者。
   - 用途：生成器在处理大量数据、无限序列或惰性计算时非常有用，它节省了内存空间，并且可以实现惰性求值，按需生成数据。

总结来说，**装饰器用于为函数添加额外功能**，**迭代器用于遍历可迭代对象的元素**，**生成器是一种特殊的迭代器，用于按需生成数据**。这些概念都是Python编程中非常重要的基础知识。

<a name="eFYkJ"></a>
## 迭代器和生成器的区别
迭代器（Iterator）和生成器（Generator）都是在Python中用于处理可迭代对象的概念，但它们之间有一些区别。

1.  **定义：** 
   - 迭代器是一个对象，它实现了两个方法：`__iter__()` 和 `__next__()`（在Python 2中是`next()`）。通过这两个方法，迭代器可以逐个返回元素，直到没有更多元素时引发 `StopIteration` 异常。
   - 生成器是一种特殊的迭代器。它是通过函数来创建的，使用 `yield` 关键字来产生元素，而不是使用 `return` 关键字。生成器函数在调用时并不立即执行，而是返回一个生成器对象，该对象可以用于按需生成数据。
2.  **数据存储：** 
   - **迭代器通常需要在内存中存储所有的数据**。例如，如果你有一个列表，并通过迭代器遍历它，那么整个列表将会存储在内存中。
   - 生成器是按需生成数据的。它并不需要将所有数据存储在内存中，**而是在需要时才产生数据。**每次生成器的 `__next__()` 方法被调用时，它会从上次 `yield` 语句的位置继续执行，产生一个新的元素。
3.  **使用：** 
   - 迭代器适用于处理大型数据集，但需要占用较多内存。在处理数据集较小时，直接使用迭代器通常是可行的。
   - 生成器适用于处理大型数据集或无限序列。由于生成器只在需要时生成数据，因此它在处理大量数据时更加高效，并且节省内存。
4.  **特点：** 
   - 迭代器是一个**通用的抽象概念**，可以用于遍历各种可迭代对象，例如列表、元组、字典等。
   - 生成器是**一种特殊的迭代器**，它是通过函数来创建的，使得数据按需生成，适用于处理大量数据或无限序列。

虽然迭代器和生成器之间有一些区别，但它们都是在处理可迭代对象时非常有用的工具。选择使用迭代器还是生成器取决于具体的场景和需求，以及对内存和性能的考虑。在处理大型数据集时，通常更倾向于使用生成器，以获得更好的性能和内存效率。

<a name="DOGkd"></a>
## pyhton闭包
<a name="k1yOV"></a>
### 什么是闭包？
**答：可以将闭包理解为一种特殊的函数，这种函数由两个函数的嵌套组成，外函数和内函数**。**在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。**<br />**答法2：内部函数对外部函数作用域里变量的引用（非全局变量），则称内部函数为闭包。**

_当某个_**_函数_**_被当成对象返回时，_**_夹带了外部变量_**_，就形成了一个闭包。看例子。_
```python
def make_printer(msg):
    def printer():
        print msg  # 夹带私货（外部变量）
    return printer  # 返回的是函数，带私货的函数
 
printer = make_printer('Foo!')
printer()
```
支持将函数当成对象使用的编程语言，一般都支持闭包。比如Python, JavaScript。
<a name="zpuDP"></a>
### 如何理解闭包？存在的意义是什么？为什么需要闭包？
**~~答：~~**~~我个人认为，~~**~~闭包存在的意义就是它夹带了外部变量（私货），如果它不夹带外部变量，它和普通的函数就没有任何区别。~~~~同一个的函数~~**~~夹带了~~**~~不同的~~~~外部变量~~**~~，就实现了不同的功能。~~<br />答：

1. 保护数据： 闭包可以用于隐藏函数内部的数据，使得这些数据不会被外部直接访问和修改，从而实现了数据的封装和保护。
2. 延长变量生命周期： **闭包使得函数的局部变量在函数调用结束后仍然可以被保留在内存中，供下次调用时使用。**这样可以延长变量的生命周期，避免了在每次调用函数时重新初始化变量。
3. 实现回调和高阶函数： 闭包可以用于实现回调函数和高阶函数。
4. **实现装饰器**。
5. **函数工厂**：即动态地生成函数。通过闭包，我们可以根据不同的参数生成不同的函数，从而实现动态编程。
<a name="TnAhy"></a>
### 函数工厂？举个例子
函数工厂是一种利用闭包的编程技术，用于动态地生成函数。**通过函数工厂，我们可以根据不同的参数或配置生成不同的函数，从而实现动态编程。**<br />假设我们想要创建一个计算平方、立方和四次方的函数工厂。我们可以定义一个函数工厂，该工厂接受一个整数n作为参数，然后返回一个新的函数，该函数可以计算输入数值的n次方。
```python
def power_factory(n):
    def power(x):
        return x ** n
    return power

# 使用函数工厂创建不同次方的函数
square = power_factory(2)  # 创建平方函数
cube = power_factory(3)    # 创建立方函数
quartic = power_factory(4) # 创建四次方函数

# 使用新函数进行计算
print(square(5))  # 输出：25 (5的平方)
print(cube(5))    # 输出：125 (5的立方)
print(quartic(5)) # 输出：625 (5的四次方)
```

<a name="Jxt3c"></a>
## python的数据类型
Python是一种动态类型语言，它支持多种内置的数据类型，这些数据类型包括：

1.  **数值类型：** 
   - int（整数）：例如，1, -5, 100。
   - float（浮点数）：例如，3.14, -0.5, 2.0。
2.  **字符串类型（str）：** 
   - 用单引号或双引号括起来的字符序列。例如，'hello', "Python", "12345"。
3.  **布尔类型（bool）：** 
   - 用于表示真（True）或假（False）的值。在条件判断、循环等语句中经常使用。
4.  **列表（list）：** 
   - 有序的可变序列，**可以包含任意类型的元素**。使用方括号括起来，例如，[1, 2, 3], ['apple', 'orange', 'banana']。
5.  **元组（tuple）：** 
   - 有序的不可变序列，**可以包含任意类型的元素**。使用圆括号括起来，例如，(1, 2, 3), ('a', 'b', 'c')。
6.  **集合（set）：** 
   - 无序的可变集合，元素没有重复，**支持集合操作如并集、交集**等。使用大括号或`set()`函数创建，例如，{1, 2, 3}, set([4, 5, 6])。
7.  **字典（dict）：** 
   - 无序的键值对映射，用于存储具有关联关系的数据。使用大括号括起来，例如，{'name': 'Alice', 'age': 30}。
8.  **None类型：** 
   - 表示空值或缺失值，通常用于初始化变量或作为函数的返回值。

除了这些内置数据类型外，Python还支持其他的扩展数据类型，如集合（set）和字典（dict）推导式、命名元组（namedtuple）、默认字典（defaultdict）、有序字典（OrderedDict）等。此外，Python还支持用户自定义的类来创建自定义数据类型。<br />Python的灵活的数据类型和**丰富的数据结构**使其成为一种强大的编程语言，在处理各种数据和问题时都具有很高的适用性。
<a name="wayra"></a>
## tuple和list有什么区别（列表和元组的区别）
Tuple（元组）和List（列表）是两种Python中常见的数据类型，它们之间的主要区别包括以下几点：

1.  **可变性：** 
   - Tuple是不可变的（immutable），一旦创建后，其元素不可修改，添加或删除。你可以认为Tuple是只读的。
   - List是可变的（mutable），你可以修改、添加或删除列表中的元素。
2.  **语法表示：** 
   - Tuple使用圆括号 `()` 来表示，例如：`(1, 2, 3)`。
   - List使用方括号 `[]` 来表示，例如：`[1, 2, 3]`。
3.  **性能：** 
   - **由于Tuple是不可变的，它在创建后的内存占用和访问速度通常优于List。因为tuple不可变，内存大小固定，**因此Python可以对Tuple进行更多的优化。
   - **List在修改和扩展时可能涉及到内存的重新分配，因此性能可能略低于Tuple。**
4.  **方法支持：** 
   - Tuple由于不可变性，具有较少的内置方法，只有`count()`和`index()`等少数方法可用。
   - List拥有更多的内置方法，如`append()`、`insert()`、`remove()`、`pop()`等，可以方便地对列表进行操作。
5.  **使用场景：** 
   - Tuple适用于表示一组不希望被修改的数据，例如函数返回多个值、坐标点等。
   - List适用于表示一组动态数据，例如一系列的任务、数据集等。
6.  **迭代性：** 
   - 由于Tuple是不可变的，它在迭代时可能比List稍微更快一些。
   - List在迭代时需要考虑可能的修改，因此可能在某些情况下更慢。

虽然Tuple和List在某些方面有不同，但它们都是有序的集合，可以包含多种数据类型的元素。选择使用哪种数据类型取决于你的需求和对数据修改和访问的要求。如果需要一个不可变的集合，适用于存储不会改变的数据，那么Tuple是一个好的选择。如果需要一个可变的集合，适用于频繁地修改和操作数据，那么List更合适。
<a name="e5oK3"></a>
## set是一个怎样的数据类型
Set（集合）是一种**无序**、**可变**且**不重复**的数据类型。它是一种**用于存储多个唯一元素的容器**，类似于数学中的集合。<br />Set具有以下几个特点：

1.  **无序性：** Set中的元素是无序的，它们没有固定的顺序，因此不能通过索引来访问元素。 
2.  **不重复性：** Set中的元素是唯一的，即每个元素只能在Set中出现一次。如果尝试将重复的元素添加到Set中，那么只会保留一个。 
3.  **可变性：** Set是可变的，可以添加或删除元素。你可以使用`add()`方法来添加元素，使用`remove()`方法来删除元素。 
4.  **元素类型：** Set中的元素可以是任何**可哈希（hashable）的数据类型**，例如**数值、字符串、元组**，但不能包含可变数据类型，如列表或其他集合。 

Set在Python中使用大括号 `{}` 或者使用`set()`函数来创建。**创建空集合时只能使用**`**set()**`**，因为使用**`**{}**`**会创建一个空字典。**<br />以下是Set的一些常见操作：
```python
# 创建Set
my_set = {1, 2, 3}
another_set = set([4, 5, 6])

# 添加元素
my_set.add(4)

# 删除元素
my_set.remove(2)

# 集合运算
union_set = my_set | another_set  # 并集
intersection_set = my_set & another_set  # 交集
difference_set = my_set - another_set  # 差集

# 遍历集合
for element in my_set:
    print(element)
```

Set在处理一组元素时非常有用，特别是当你需要保留唯一值或进行集合运算时。由于Set是可变的，你可以方便地对其进行添加、删除和更新操作。但需要注意的是，由于Set是无序的，不能通过索引访问元素，所以在需要有序集合时，你应该使用列表（List）或元组（Tuple）而不是Set。
<a name="kk6pq"></a>
### 什么是可哈希数据类型？有哪些？
可哈希（hashable）数据类型是指在Python中可以作为字典的键（key）的数据类型。具体来说，可哈希数据类型是那些在创建后不可改变的数据类型，因为字典的键必须是唯一的且不可变的。

以下是Python中常见的可哈希数据类型：

1.  **不可变的基本数据类型：** 
   - int（整数）
   - float（浮点数）
   - bool（布尔值）
   - str（字符串）
   - tuple（元组）
2.  **~~不可变的集合数据类型：~~**~~ ~~
   - ~~frozenset（冻结集合）~~

**可哈希数据类型的特点是，它们在创建后不可改变。**这是因为字典中的键实际上是根据键的哈希值来进行存储和检索的，如果键是可变的，则在改变键的值后，其哈希值也会改变，导致无法准确地找到对应的键。<br />除了以上列出的数据类型，其他所有数据类型都是不可哈希的，包括**列表（List）、字典（Dictionary）和集合（Set）**。因此，这些不可哈希数据类型不能用作字典的键，但可以作为字典的值。<br />需要注意的是，**虽然字符串是不可变的，但它的哈希值是根据其内容计算的，而不是根据其内存地址**。这**意味着两个内容相同的字符串会有相同的哈希值，因此可以作为字典的键。**而列表和集合是可变的，它们的哈希值是根据其内存地址计算的，所以不能用作字典的键。
<a name="E4MEa"></a>
### 数据类型之间如何转换？
在Python中，你可以使用**内置函数**或**特定类型的构造函数**来进行数据类型之间的转换。以下是一些常见的数据类型转换方法：

1.  **字符串和数值类型之间的转换：** 
   - 使用`str()`函数**可以将数值类型转换为字符串类型**，例如：`str(123)`将整数123转换为字符串"123"。
   - 使用`int()`函数**可以将字符串类型转换为整数类型**，例如：`int("456")`将字符串"456"转换为整数456。但要注意，转换的字符串**必须是合法**的整数格式，否则会引发`ValueError`异常。
   - 使用`float()`函数**可以将字符串类型转换为浮点数类型**，例如：`float("3.14")`将字符串"3.14"转换为浮点数3.14。同样，转换的字符串必须是合法的浮点数格式。
2.  **列表、元组和集合之间的转换：** 
   - 使用`list()`函数可以**将元组或集合转换为列表**，例如：`list((1, 2, 3))`将元组(1, 2, 3)转换为列表[1, 2, 3]，`list({1, 2, 3})`将集合{1, 2, 3}转换为列表[1, 2, 3]。
   - 使用`tuple()`函数可以**将列表或集合转换为元组**，例如：`tuple([1, 2, 3])`将列表[1, 2, 3]转换为元组(1, 2, 3)，`tuple({1, 2, 3})`将集合{1, 2, 3}转换为元组(1, 2, 3)。
   - 使用`set()`函数可以**将列表或元组转换为集合**，例如：`set([1, 2, 3])`将列表[1, 2, 3]转换为集合{1, 2, 3}，`set((1, 2, 3))`将元组(1, 2, 3)转换为集合{1, 2, 3}。需要注意的是，集合只能包含可哈希的元素，因此列表和元组中的元素必须是可哈希的。
3.  **其它类型之间的转换：** 
   - 使用`dict()`函数**可以将包含键值对的可迭代对象转换为字典**。例如：`dict([('a', 1), ('b', 2)])`**将列表转换为字典**{'a': 1, 'b': 2}。
   - 使用`bool()`函数**可以将其他数据类型转换为布尔类型**。**任何非零数值、非空字符串、非空列表、非空元组、非空集合等都会转换为**`**True**`**，**而零值、空字符串、空列表、空元组、空集合等都会转换为`False`。

需要注意的是，有些数据类型之间的转换可能涉及到数据的丢失或不精确性。在进行数据类型转换时，要确保数据的合法性和正确性。如果存在不确定性或不合法的转换，可能会引发异常或得到意外的结果。因此，在进行数据类型转换时要格外小心，并确保对数据进行适当的验证和处理。
<a name="dNF0D"></a>
## dict实现原理，使用什么数据结构实现
list有序 dict有序无序(都有)<br />**Dict（字典）的实现原理：**

- Dict是一个**哈希表（Hash Table）数据结构**。它**使用了哈希函数来将键（key）映射到哈希表中的一个槽位（bucket）。**
- 哈希表是由多个槽位组成的数组，每个槽位可以存储一个键值对。当你想要获取字典中某个键的值时，Python会通过哈希函数计算出键对应的槽位，然后直接访问槽位中的值，这样可以实现快速的查找操作。
- 字典的键必须是可哈希（hashable）的，也就是说，键必须是不可变的数据类型，如数值、字符串、元组等。这是因为字典的哈希表**依赖于键的哈希值**来**进行映射**。
- 当**字典的键数量增加时，Python会自动进行扩容**。扩容的过程涉及到**重新计算键的哈希值，并将键重新映射到新的槽位上。**

需要注意的是，List是有序的数据结构，元素的顺序与添加顺序一致。而Dict是无序的数据结构，元素的顺序是根据键的哈希值来确定的。**如果需要有序的键值对集合，可以使用有序字典（OrderedDict）或使用Python3.7以后的版本，因为在Python3.7以后，字典保持了插入顺序。**
<a name="MdgCm"></a>
#### python3.7之后为什么dict有序了？
而在Python 3.7中，**字典的实现从“哈希表加链表”改进为“哈希表加开放寻址法”。**在新的实现中，除了保持O(1)的平均查找时间外，字典还能保持插入顺序。新的实现在字典**内部使用了一个有序的数组，用于记录键值对的插入顺序**。**因此，在遍历字典时，元素的顺序会与插入顺序一致。**<br />这个改进使得Python中的普通字典也具有了有序性，**但与OrderedDict相比，它的内存占用更低，性能也更好。**因此，在Python 3.7及以后的版本中，如果需要保持插入顺序，可以直接使用普通的字典而**无需额外引入OrderedDict**。
<a name="kZphh"></a>
#### dict的哈希函数？
在Python中，dict（字典）使用的哈希函数是MurmurHash算法。MurmurHash是一种非加密型的哈希函数，具有良好的性能和低碰撞（哈希冲突）概率，适合用于字典等数据结构的实现。
<a name="ycrd9"></a>
#### python3.7前的dict的哈希冲突的解决方案
对于哈希冲突的解决方案，Python的dict使用了**链地址法**（Chaining）。具体来说，当发生哈希冲突时，Python会在哈希表的槽位中维护一个链表（或者更准确地说是链表的头结点），将冲突的键值对添加到链表中。如果多个键产生了相同的哈希值，它们会被添加到同一个槽位的链表中，形成一个链式结构。
<a name="E8xOB"></a>
#### python3.7后的dict的哈希冲突的解决方案
开放地址法+线性探测。
<a name="FIIIl"></a>
#### 访问存在哈希冲突的哈希表时如何保证key, value的正确性？
在访问哈希表时，当我们通过键访问特定的值时，Python会**使用哈希函数计算键的哈希值**，并找到对应的槽位。然后，它**会检查该槽位中的键是否与要访问的键匹配**。如果匹配成功，就返回对应的值；**如果不匹配，则继续向后探测，查找下一个槽位**。
<a name="ArRsR"></a>
### OrderedDict的实现原理？
`OrderedDict`的原理是通过**双向链表（**doubly-linked list）和**字典（**`**dict**`**）的结合**来实现的。在Python 3.7及以后的版本中，普通的字典也会保持插入顺序，但在之前的版本中，只有`OrderedDict`才能保证元素的有序性。<br />具体来说，`OrderedDict`中的**每个键值对都保存了两个引用，一个指向前一个元素**，**一个指向后一个元素，这样就构成了一个双向链表**。另外，`OrderedDict`还有一个字典用于实现键到值的映射，这样可以实现快速的查找操作。<br />在插入元素时，`OrderedDict`会**将元素添加到链表的尾部**，并在字典中记录键到值的映射。这样，元素的插入顺序就得到了保留。而在普通的字典中，元素的插入顺序并不会被记录下来，因此在遍历字典时，元素的顺序可能与插入顺序不一致。<br />需要注意的是，由于`OrderedDict`需要维护双向链表和字典，因此相对于普通的字典，它会占用更多的内存。因此，在不需要保持元素顺序的情况下，使用普通的字典会更节省内存和更高效。<br />以下是一个简单的示例，展示了`OrderedDict`的使用：

```python
from collections import OrderedDict

# 创建一个有序字典并插入元素
ordered_dict = OrderedDict()
ordered_dict['a'] = 1
ordered_dict['b'] = 2
ordered_dict['c'] = 3

# 遍历有序字典，输出的顺序与插入顺序一致
for key, value in ordered_dict.items():
    print(key, value)
```

输出结果会按照插入顺序输出：

```
a 1
b 2
c 3
```

<a name="fs1nZ"></a>
### python3.7 dict和OrderedDict的区别
实现上：dict是有序数组+哈希表，哈希冲突采用开放地址法；OrderedDict**是双向链表+dict，相比dict额外占用了双向链表的内存。**
<a name="ebeu0"></a>
### set实现？数据结构？
set的实现基于**哈希表**，它使用哈希函数将元素映射到哈希表中的槽位，并在槽位中存储元素的值。当我们向set中添加元素时，Python会根据哈希函数计算元素的哈希值，并找到对应的槽位。如果槽位中没有其他元素，直接将元素放入槽位；如果槽位中已经有其他元素，会检查该元素是否与要添加的元素相同（通过哈希值和相等性比较）。如果相同，表示元素已经存在，不进行重复添加；如果不相同，发生哈希冲突，通过**开放寻址法+线性探测**的方式继续查找下一个空槽位，并将元素放入其中。<br />set的实现使得元素的添加、删除和查找操作都具有O(1)的平均时间复杂度，因为哈希表能够提供快速的键值查找。<br />由于set是无序的，它不会记录元素的插入顺序。如果**需要有序的集合，可以使用collections模块中的OrderedSet或在Python 3.7及以后版本中直接使用普通的set，**因为在Python 3.7及以后版本中，set会保持元素的插入顺序。

<a name="r2NjZ"></a>
### list实现？数据结构？
在Python中，List的底层数据结构是一个动态数组（Dynamic Array）。这意味着List是一个可变长度的数组，可以根据需要动态增长或缩小。
<a name="dWaeP"></a>
#### list扩容的原理？
List的动态数组实现是通过C语言的数组来实现的。在Python中，**List的元素存储在一个C数组中，当List的长度超过当前数组的容量时，会触发扩容操作。**<br />List的扩容原理如下：

- 初始容量： 当你**创建一个新的空List时，它会分配一定的初始容量来存储元素。**这个初始容量通常是较小的固定值，比如8或16，这样可以节省内存。
- 动态增长： 当你**往List中添加元素时，如果当前List的长度超过了数组的容量**，就需要进行扩容。**扩容过程会创建一个更大的新数组，并将原来数组中的元素复制到新数组中。**
- **增长策略**： 扩容过程中，通常会采用一种增长策略来确定新数组的大小。在Python中，**List的增长策略是每次扩容时将数组容量翻倍**。这意味着新数组的大小将是原数组大小的两倍。例如，如果原数组容量是8，那么扩容后的新数组容量将是16；如果原数组容量是16，那么扩容后的新数组容量将是32，依此类推。
- 复制元素： 在进行扩容时，**需要将原数组中的元素复制到新数组中。**这个过程涉及到将原数组中的每个元素逐个复制到新数组中，**因此扩容的时间复杂度是O(n)，**其中n是List的长度。
- 原地扩容： 需要注意的是，List的扩容是在原地进行的，即在原有的内存地址上进行操作。这意味着扩容后的新数组仍然在原来的地址上，不会导致额外的内存分配和释放操作。

通过动态数组的扩容策略，Python的List可以在增加元素时动态地调整大小，从而实现了高效的添加操作。但值得注意的是，由于扩容操作涉及到元素复制，如果频繁进行大量的添加操作，可能会导致性能损耗。因此，在处理大量数据时，如果知道List的大小，最好在创建List时指定一个适当的初始容量，以避免频繁的扩容操作。

<a name="U4aMX"></a>
## 链表和数组的区别？
Python没有内置的链表数据结构，但是可以使用类来实现或者用collection库中的deque来实现类似的功能。<br />链表（linked list）和数组（array）是两种常见的数据结构，它们在存储和访问数据时有一些重要的区别：

1.  存储方式： 
   - 数组：**数组是一种连续的内存块**，它在内存中存储元素，每个元素都占用固定的内存空间。由于元素是连续存储的，因此可以通过索引快速访问数组中的任意元素。
   - 链表：链表是由节点组成的数据结构，每个节点包含数据和指向下一个节点的引用。由于节点在内存中可以是离散的，因此**链表中的元素在内存中可以不连续存储**。
2.  大小： 
   - 数组：**在创建数组时需要预先指定大小**，它的大小是固定的，不能随意增加或缩小。
   - 链表：**链表的大小可以动态增长或缩小**，它不需要预先指定大小。
3.  插入和删除： 
   - 数组：在数组中插入或删除元素通常需要移动其他元素，因为数组的元素是连续存储的，所以这个**操作的时间复杂度是O(n)，**其中n是数组的大小。
   - 链表：在链表中插入或删除元素只需要修改节点的引用，而不需要移动其他元素。这**使得插入和删除操作的时间复杂度是O(1)**，即常数时间。（当然，找到元素也是需要O(1)的时间）
4.  访问时间： 
   - 数组：由于数组的元素是连续存储的，通过**索引访问元素的时间复杂度是O(1)**，即常数时间。
   - 链表：在链表中访问元素需要从头开始遍历链表，直到找到目标元素。因此，**访问元素的时间复杂度是O(n)**，其中n是链表的大小。

综上所述，数组适用于需要频繁访问元素的情况，而链表适用于需要频繁插入和删除元素的情况。每种数据结构都有其优势和劣势，选择合适的数据结构取决于具体的应用场景和操作需求。
<a name="OO5iD"></a>
## 堆和队列的区别以及实现？
Python中的堆（heap）和队列（queue）是两种不同的数据结构，它们分别用于不同的场景。

1. 堆（heap）： 
   - **堆是一种特殊的树状数据结构**，它是一个**完全二叉树**（或近似完全二叉树），并且具有以下性质： 
      - 对于最大堆（max heap）：每个节点的值都大于或等于其子节点的值。
      - 对于最小堆（min heap）：每个节点的值都小于或等于其子节点的值。
   - 堆通常用于**实现优先级队列**，其中最大（或最小）元素总是位于堆的根节点，可以高效地进行插入和删除操作，并保持堆的结构性质。

Python中的`heapq`模块提供了对堆操作的支持，可以通过`heapq`模块来创建和操作堆。例如，`heapq.heappush()`用于向堆中插入元素，`heapq.heappop()`用于从堆中弹出最小（最大）元素。

2. 队列（queue）： 
   - 队列是一种先进先出（FIFO）的数据结构，其中元素的添加和删除是按照顺序进行的。新元素被添加到队列的末尾，而从队列中删除元素是从队列的开头进行的。
   - 队列通常用于**实现任务调度**、**线程间通信等场景**，确保任务按照顺序执行，避免竞争条件和并发问题。

Python中的`queue`模块提供了对队列操作的支持，包括多种类型的队列实现，如`queue.Queue`（普通队列）、`queue.LifoQueue`（后进先出队列）、`queue.PriorityQueue`（优先级队列）等。你可以根据实际需求选择合适的队列类型。<br />总结：堆是一种树状数据结构，用于实现优先级队列，Python中使用`heapq`模块实现堆操作。队列是一种线性数据结构，用于实现任务调度等场景，Python中使用`queue`模块实现队列操作。
<a name="onNZj"></a>
### python中heapq是大根堆还是小根堆？
Python的`heapq`模块实现的是小根堆（min heap）。

在小根堆中，每个父节点的值都小于或等于其子节点的值。这意味着小根堆的根节点是其中的最小值。`heapq`模块提供的函数可以用于创建和操作小根堆，包括将元素插入堆、从堆中弹出最小元素、堆排序等操作。<br />**要使用**`**heapq**`**模块操作大根堆（max heap），可以通过在插入元素时取其负值来实现。**这样，在小根堆中实际保存的是元素的相反数，使得最小值变成最大值。<br />以下是一个简单示例，展示如何使用`heapq`模块实现小根堆和大根堆：
```python
import heapq

# 小根堆
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 4)
heapq.heappush(heap, 2)

print("Min heap:", heap)  # 输出结果：Min heap: [1, 2, 4, 3]

# 大根堆
max_heap = []
for item in [3, 1, 4, 2]:
    heapq.heappush(max_heap, -item)

print("Max heap:", [-item for item in max_heap])  # 输出结果：Max heap: [4, 3, 2, 1]
```
在上述示例中，我们使用`heapq.heappush()`向堆中插入元素，并通过取负值来实现大根堆。请注意，虽然小根堆和大根堆在元素排列上有所不同，但它们都是有效的堆数据结构，具有堆的性质。

<a name="n90Wh"></a>
## dict的key可以是什么数据类型
可哈希数据类型，不可变基本数据类型。

1. **不可变的基本数据类型：** 
   - int（整数）
   - float（浮点数）
   - bool（布尔值）
   - str（字符串）
   - tuple（元组）
<a name="AcwmK"></a>
### tuple string list可以做key吗
tuple、string可以，list不行。<br />但是当不可变类型中含有可变类型元素时也不可以做key。<br />比如tuple类型的`t1 = ([1,2,3], 2, 3)`，是一个合法的tuple，但是不可以作为key，因为元素包含列表。
<a name="GfjCL"></a>
### dict中每个key不一样 分别是不同的数据类型可以吗
可以。key、value都可以是不同的数据类型，只要key满足可哈希类型就行。
<a name="sUZZK"></a>
## 一个函数内返回不同数据类型可以吗？
可以。<br />Python是一种动态类型语言，不要求函数的返回类型在定义函数时就指定，而是在运行时根据实际情况确定返回类型。
<a name="oqWhz"></a>
## 一个函数内通过不同条件返回值数量不同可以吗？
可以。返回多个返回值时默认元组返回。
<a name="Jf6pO"></a>
## python 中括号小括号大括号代表什么数据类型
list, tuple, dict<br />{}也可以表示set。但是初始化若是空的{}则默认是字典。初始化直接指定元素可以为set。
<a name="f54Qd"></a>
## python中的*和**的区别
在Python中，`*`和`**`是两种不同的操作符，用于**处理函数参数**和**解包序列（序列拆包）**的情况。

1.  `*`操作符： 
   - 在函数参数中，`*`操作符用于将一个元组（或可迭代对象）展开为位置参数。这样，你可以在函数定义时接收不定数量的参数，并将它们作为一个元组处理。
   - 在序列解包中，`*`操作符用于**将一个序列（列表、元组、字符串等）拆包为单独的元素**。这样，你可以将一个序列中的元素依次赋值给多个变量。

示例1：函数参数中的`*`
```python
def my_func(*args):
    for arg in args:
        print(arg)

my_func(1, 2, 3)   # 输出结果：1 2 3
```
示例2：序列解包中的`*`
```python
my_list = [1, 2, 3]
a, b, *rest = my_list
print(a)      # 输出结果：1
print(b)      # 输出结果：2
print(rest)   # 输出结果：[3]
```

2.  `**`操作符： 
   - 在函数参数中，`**`操作符用于**将一个字典展开为关键字参数**。这样，你可以在函数定义时接收不定数量的关键字参数，并将它们作为一个字典处理。
   - 在字典解包中，`**`操作符**用于将一个字典的键值对解包**，并作为关键字参数传递给函数。

示例1：函数参数中的`**`
```python
def my_func(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_func(name='John', age=25)   # 输出结果：name John, age 25
```
示例2：字典解包中的`**`
```python
my_dict = {'name': 'John', 'age': 25}
my_func(**my_dict)   # 输出结果：name John, age 25
```

总结：

- `*`用于函数参数时，接收多个位置参数（元组）或拆包序列中的多个元素。
- `**`用于函数参数时，接收多个关键字参数（字典）或拆包字典中的多个键值对。

<a name="OSkQv"></a>
## python的*arg和**kwrg区别
在Python中，`*args`和`**kwargs`是两种特殊的参数形式，用于处理函数中的可变数量的位置参数和关键字参数。它们的使用方式和作用如下：

1.  `*args`（可变数量的位置参数）： 
   - 在函数定义时，`*args`用于表示接收不定数量的位置参数，并将它们作为一个元组（tuple）传递给函数。
   - 在函数调用时，可以传递任意数量的位置参数给`*args`，它们会被收集成一个元组传递给函数。
   - 通常用于处理不确定数量的位置参数情况。

示例： 
```python
def my_function(*args):
    for arg in args:
        print(arg)

my_function(1, 2, 3)  # 输出结果：1 2 3
my_function('hello', 'world')  # 输出结果：hello world
```

2.  `**kwargs`（可变数量的关键字参数）： 
   - 在函数定义时，`**kwargs`用于表示接收不定数量的关键字参数，并将它们作为一个字典（dictionary）传递给函数。
   - 在函数调用时，可以传递任意数量的关键字参数给`**kwargs`，它们会被收集成一个字典传递给函数。
   - 通常用于处理不确定数量的关键字参数情况。

示例： 
```python
def my_function(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_function(name='John', age=25)  # 输出结果：name John, age 25
my_function(city='New York', country='USA')  # 输出结果：city New York, country USA
```

注意事项：

- 在函数定义中，`*args`和`**kwargs`的命名可以是任意的，但习惯上使用`*args`和`**kwargs`来表示这种参数形式，以便更好地理解。
- `*args`和`**kwargs`可以同时在函数定义中使用，此时`*args`会接收位置参数，`**kwargs`会接收关键字参数。

示例：
```python
def my_function(arg1, arg2, *args, **kwargs):
    print("arg1:", arg1)
    print("arg2:", arg2)
    print("args:", args)
    print("kwargs:", kwargs)

my_function(1, 2, 3, 4, name='John', age=25)
# 输出结果：
# arg1: 1
# arg2: 2
# args: (3, 4)
# kwargs: {'name': 'John', 'age': 25}
```

<a name="WAjOE"></a>
## 用python实现lambda
在Python中，可以使用`lambda`关键字创建匿名函数，也称为lambda函数。lambda函数是一种简洁的方式来定义简单的函数，它通常用于需要一个简单函数而不想明确定义函数的场景。

lambda函数的一般形式为：

```python
lambda arguments: expression
```

其中，`lambda`关键字表示创建一个lambda函数，`arguments`是函数的参数列表，`expression`是函数的返回值表达式。

下面是一些使用lambda函数的示例：

示例1：lambda函数接收两个参数，并返回它们的和。

```python
add = lambda x, y: x + y
print(add(3, 5))  # 输出结果：8
```

示例2：lambda函数接收一个参数，返回其平方。

```python
square = lambda x: x**2
print(square(4))  # 输出结果：16
```

示例3：lambda函数接收一个字符串参数，返回其首字母大写的版本。

```python
capitalize = lambda s: s.capitalize()
print(capitalize('hello'))  # 输出结果：Hello
```

请注意，虽然lambda函数可以完成一些简单的功能，但建议在需要复杂逻辑或多行代码的情况下使用普通函数定义，以提高代码的可读性和维护性。lambda函数通常用于简单的映射、过滤、排序等函数式编程的场景。

<a name="srUvU"></a>
## python zip，map
`zip`和`map`是Python中常用的两个函数，用于处理序列数据的操作。它们分别具有以下功能：

1.  `zip`函数： 
   - `zip`函数可以接受多个序列（列表、元组等），并将相同位置的元素打包成一个元组，然后**返回一个包含这些元组的迭代器**。这意味着，`zip`函数将多个序列中的元素一一对应地组合在一起。
   - 如果传递给`zip`函数的序列长度不一致，**它将以最短的序列长度为准。多余的元素将被忽略。**
   - 通常用于在循环中同时迭代多个序列。

示例： 
```python
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 22]
countries = ['USA', 'Canada', 'UK']

for name, age, country in zip(names, ages, countries):
    print(name, age, country)

# 输出结果：
# Alice 25 USA
# Bob 30 Canada
# Charlie 22 UK
```

2.  `map`函数： 
   - `map`函数用于**对一个序列（列表、元组等）中的每个元素应用同一个函数**，**并返回一个包含结果的迭代器。**
   - `map`函数接受两个参数，第一个参数是一个函数，第二个参数是一个序列。它会将函数应用于序列中的每个元素，并返回结果。
   - 如果传递给`map`函数的序列长度不一致，它将**以最短的序列长度为准。多余的元素将被忽略。**

示例： 
```python
def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
squared_numbers = map(square, numbers)
print(list(squared_numbers))  # 输出结果：[1, 4, 9, 16, 25]
```

需要注意的是，`map`函数的**返回值是一个迭代器**，可以使用`list()`函数将其转换为列表。同样地，`zip`函数**也返回一个迭代器**，如果需要将其结果保存为列表，也可以使用`list()`函数。

<a name="mz0ol"></a>
## python浅拷贝和深拷贝
在Python中，浅拷贝（shallow copy）和深拷贝（deep copy）是用于复制对象的两种不同方式。

1.  浅拷贝（Shallow Copy）： 
   - **浅拷贝创建一个新的对象，然后将原始对象的元素（如列表或字典中的元素）复制到新对象中。**但是，对于元素本身，**仅复制引用，而不是创建新的对象**。换句话说，**浅拷贝只复制对象的第一层元素，不会递归复制所有嵌套对象。**
   - 如果原始对象**包含不可变对象**（如整数、字符串、元组等），**那么浅拷贝会创建新的对象**。但如果原始对象**包含可变对象**（如列表、字典、集合等），那么浅拷贝会**共享这些可变对象。**

在Python中，可以使用`copy`模块的`**copy()**`**函数来实现浅拷贝。**<br />示例： 
```python
import copy

list1 = [1, [2, 3], 4]
list2 = copy.copy(list1)

list2[1][0] = 10

print(list1)  # 输出结果：[1, [10, 3], 4]
print(list2)  # 输出结果：[1, [10, 3], 4]
```

2.  深拷贝（Deep Copy）： 
   - 深拷贝**创建一个全新的对象**，并**递归地复制原始对象及其所有嵌套对象的所有元素**。这意味着深拷贝会**创建原始对象的完全独立副本**，**与原始对象及其嵌套对象没有任何关联。**
   - 深拷贝会复制原始对象中的**所有对象**，**包括不可变对象和可变对象**，从而实现了完全的独立复制。

在Python中，可以使用`copy`模块的`**deepcopy()**`**函数来实现深拷贝。**<br />示例： 
```python
import copy

list1 = [1, [2, 3], 4]
list2 = copy.deepcopy(list1)

list2[1][0] = 10

print(list1)  # 输出结果：[1, [2, 3], 4]
print(list2)  # 输出结果：[1, [10, 3], 4]
```

总结：

- 浅拷贝复制对象的第一层元素，并共享嵌套对象。
- 深拷贝递归复制所有嵌套对象，创建完全独立的副本。

<a name="Hllza"></a>
### python中深拷贝和浅拷贝的本质区别
本质区别在于拷贝对象的深度和是否共享内存：

- 浅拷贝：
1. **浅拷贝只拷贝对象的顶层元素，不会递归拷贝嵌套对象**。拷贝后的新对象中的嵌套对象是原始对象中嵌套对象的引用，也就是说，原始对象和浅拷贝对象共享这些嵌套对象的内存。
2. **当原始对象中的元素是不可变对象（如整数、字符串、元组等）时，浅拷贝会创建新的对象。但当原始对象中的元素是可变对象（如列表、字典、集合等）时，浅拷贝会共享这些可变对象。**
- 深拷贝：
1. **深拷贝会递归地拷贝原始对象及其所有嵌套对象。拷贝后的新对象与原始对象完全独立，不共享任何嵌套对象的内存。**
2. 无论原始对象中的元素是可变对象还是不可变对象，深拷贝都会创建它们的全新副本，不共享内存。

这个区别非常重要，尤其在处理嵌套对象、避免副作用或引发意外行为时，深拷贝是更安全的选择。但是需要注意，深拷贝可能会比浅拷贝耗费更多的时间和内存，因为它要递归地复制整个对象结构。

<a name="Jvr9t"></a>
## python函数参数传递
在Python中，函数参数的传递方式有两种：**值传递**和**引用传递**。理解这两种传递方式对于函数的使用非常重要。

1.  值传递（Pass by Value）： 
   - 值传递是指在将参数传递给函数时，传递的是参数的值的副本而不是参数本身。函数内部对参数值的修改不会影响到原始参数。
   - 在值传递中，对于**不可变对象（如整数、字符串、元组等），函数内部对参数的修改不会影响到函数外部的原始对象。**
   - 例如，在函数内部对一个整数参数进行修改，不会影响函数外部的原始整数。

示例： 
```python
def modify_value(x):
    x = x + 1

a = 10
modify_value(a)
print(a)  # 输出结果：10，a的值没有改变
```

2.  引用传递（Pass by Reference）： 
   - 引用传递是指在将参数传递给函数时，传递的是参数的引用或地址，而不是参数的副本。函数内部对参数引用的对象的修改会影响到原始参数。
   - 在引用传递中，对于**可变对象（如列表、字典、集合等），函数内部对参数的修改会影响到函数外部的原始对象。**
   - 例如，在函数内部对一个列表参数进行修改，会影响函数外部的原始列表。

示例： 
```python
def modify_list(lst):
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # 输出结果：[1, 2, 3, 4]，my_list的值被修改
```

需要注意的是，Python中的**函数参数传递方式是根据参数的类型来决定的**。对于不可变对象，采用值传递；对于可变对象，采用引用传递。在实际使用函数时，理解参数传递方式可以避免出现意外的副作用和错误。
<a name="VG6EB"></a>
## python执行过程

1.  词法分析和语法分析： 
   - Python代码首先经过词法分析器（Lexer），将代码分解为一个个的词法单元（tokens），如标识符、关键字、运算符等。
   - 然后经过语法分析器（Parser），将词法单元组织成抽象语法树（Abstract Syntax Tree，AST），确定代码的语法结构。
2.  字节码编译： 
   - Python解释器将抽象语法树编译为字节码（bytecode），这是一种中间形式，类似于汇编语言，但不是直接在硬件上执行的机器代码。
3.  字节码解释执行： 
   - Python解释器对字节码进行解释执行。它逐条解释字节码指令，执行代码逻辑，并且根据执行结果执行相应的操作。
4.  运行时环境： 
   - 在解释执行过程中，Python解释器会创建一个运行时环境，包括全局作用域、局部作用域、内置函数、模块等。在运行时环境中，变量、函数、对象等都会被创建和管理。
5.  内存管理： 
   - Python解释器负责管理内存的分配和释放。它使用自动垃圾回收机制来回收不再使用的对象，使开发者无需手动管理内存。
6.  动态特性： 
   - Python是一门动态语言，允许在运行时动态地创建新的函数、类和对象，以及修改已有的函数、类和对象。

总结：Python是一种解释执行的动态语言。它通过词法分析和语法分析将代码转换为抽象语法树，再编译为字节码进行解释执行。在运行时环境中，Python解释器管理内存和变量，并实现动态特性。这使得Python非常灵活且易于使用，但也有一定的运行时开销。
<a name="iOMTI"></a>
## python 打开文件的几种方法
open<br />with open<br />读取模式 +号：支持读写。<br />读取模式"rb"：读二进制文件。
<a name="pgEdR"></a>
## with 做什么的，有自己实现过吗
`with`语句是Python中**用于管理资源的一种语法结构**，也称为**上下文管理器（Context Manager）**。它提供了一种简洁的方式来确保在代码块执行完毕后，资源会被正确释放，无论代码块是否发生异常。<br />`with`语句的基本语法为：
```python
with expression as target:
    # 代码块
```

在上述语法中，`expression`是**一个上下文管理器对象**，它会返回一个上下文对象。这个上下文对象会被赋值给`target`，在代码块中可以使用`target`来访问上下文对象。<br />实际上，`**expression**`**必须是一个定义了**`**__enter__()**`**和**`**__exit__()**`**方法的对象**，这些方法分别定义了在进入和退出代码块时应该执行的操作。<br />`with`语句的执行过程如下：

1. `expression.__enter__()`方法被调用，它返回一个上下文对象，并将这个对象赋值给`target`。
2. 执行代码块中的代码。
3. 如果代码块执行过程中出现了异常，`expression.__exit__(exc_type, exc_value, traceback)`方法被调用，用于处理异常并清理资源。
4. 如果代码块执行完毕（无论是否出现异常），`expression.__exit__(None, None, None)`方法被调用，用于清理资源。

`with`语句的优点在于，**它可以自动管理资源的打开和关闭**，避免了手动管理资源的繁琐工作，并且在代码中更加清晰和安全。<br />**自己实现一个简单的上下文管理器并不难，只需定义一个类，并在类中实现**`**__enter__()**`**和**`**__exit__()**`**方法即可。**下面是一个简单的自定义上下文管理器的示例：
```python
class MyContextManager:
    def __enter__(self):
        print("Entering the context")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting the context")
        if exc_type is not None:
            print(f"Exception: {exc_type}, {exc_value}")

with MyContextManager() as context:
    print("Inside the context")
    # 可以在此处执行一些操作，如打开文件、建立网络连接等
    # 在代码块结束后，自动调用 MyContextManager 的 __exit__ 方法
```

输出结果：
```
Entering the context
Inside the context
Exiting the context
```
这个自定义的上下文管理器只是一个简单的示例，实际的上下文管理器可以用于更复杂的资源管理和异常处理。
<a name="zqV27"></a>
## 如果要你实现一个可以使用with语句的类，需要做什么
如果想要实现一个可以使用`with`语句的类，需要在这个类中定义`__enter__()`和`__exit__()`方法，这两个方法分别定义了在进入和退出代码块时应该执行的操作。

1.  定义`__enter__()`方法： 
   - `__enter__()`方法在进入代码块时被调用，**它负责返回一个上下文对象**。这个上下文对象可以是类的实例本身，也可以是类中的其他对象，它将在代码块中被使用。
   - 如果希望在进入代码块之前执行一些操作，可以在`__enter__()`方法中实现这些操作，并返回相应的上下文对象。
2.  定义`__exit__()`方法： 
   - `__exit__()`方法在**退出代码块时被调用，它负责处理异常和清理资源。**这个方法接受三个参数：`exc_type`、`exc_value`和`traceback`，用于处理代码块中可能发生的异常。
   - 如果希望在退出代码块时执行一些操作，比如释放资源、关闭文件等，可以在`__exit__()`方法中实现这些操作。

下面是一个简单的示例，展示如何实现一个可以使用`with`语句的类：

```python
class MyContextManager:
    def __enter__(self):
        print("Entering the context")
        return self  # 返回上下文对象，可以是类的实例本身，也可以是其他对象

    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting the context")
        if exc_type is not None:
            print(f"Exception: {exc_type}, {exc_value}")
        # 可以在此处处理异常，并进行资源清理等操作

# 使用自定义的上下文管理器
with MyContextManager() as context:
    print("Inside the context")
    # 在代码块中执行一些操作
    # 在代码块结束后，自动调用 MyContextManager 的 __exit__ 方法
```
输出结果：
```
Entering the context
Inside the context
Exiting the context
```

请注意，自定义的上下文管理器可以用于更复杂的资源管理和异常处理。在实际应用中，可以根据需要在`__enter__()`和`__exit__()`方法中实现相应的逻辑和操作。
<a name="gFEfE"></a>
## 读取文件with的好处
`with` 语句读取文件的好处：<br />使用 `with` 语句打开文件有以下好处： 

   - **自动管理文件的打开和关闭**：`with` 语句确保在代码块结束后，文件会被正确地关闭，无论代码块是否发生异常。这**避免了手动管理文件的打开和关闭，以及可能因忘记关闭文件而导致的资源泄漏。**
   - 更**简洁的代码**：`with` 语句简化了代码结构，使得文件操作更加清晰和安全。

示例： 
```python
# 传统方式打开文件
file = open('example.txt', 'r')
content = file.read()
file.close()

# 使用 with 语句打开文件
with open('example.txt', 'r') as file:
    content = file.read()
```
<a name="zgmPn"></a>
## join和+的区别
 `join()` 和 `+` 的区别： 

   -  `join()` 和 `+` 都是用于**拼接字符串**的方法，但它们有一些不同之处。 
   -  `join()` 方法： 
      - `join()` 方法是**字符串的一个方法，用于将一个可迭代对象中的元素按照指定的分隔符连接成一个新的字符串。**
      - 使用 `join()` 方法可以**避免每次拼接字符串都产生一个新的字符串对象，因为它是在一个操作中完成拼接的，效率较高。**
      - 示例：
```python
words = ['hello', 'world', 'python']
result = ' '.join(words)  # 拼接字符串，并以空格分隔
print(result)  # 输出结果：hello world python
```
 

   -  `+` 操作符： 
      - `+` 操作符用于拼接两个字符串，**并产生一个新的字符串对象**。每次使用 `+` 操作符拼接字符串时，都会创建一个新的字符串对象，**效率较低**。
      - 示例：
```python
str1 = 'hello'
str2 = 'world'
result = str1 + ' ' + str2  # 拼接字符串，并以空格分隔
print(result)  # 输出结果：hello world
```
 <br />总结： 

   - 如果需要拼接多个字符串，并且字符串在一个可迭代对象中，推荐使用 `join()` 方法，因为它的效率较高。
   - 如果只是拼接少量的字符串，使用 `+` 操作符也是可以的，但在频繁拼接大量字符串时，使用 `join()` 方法会更加高效。
<a name="o2hRb"></a>
## 知道魔法函数吗？
是在Python中具有特殊含义的方法。它们以双下划线开头和结尾，例如 __init__、__str__、__add__ 等。魔法函数用于自定义类的行为，可以在类中重写这些方法来实现特定的功能或操作。
<a name="qJosz"></a>
### 常用的5种魔法函数
以下是五个常见的魔法函数及其作用：

1. `__init__(self, ...)`: 构造函数，用于初始化对象的属性。在创建对象时自动调用，用于初始化对象的属性。示例：

```python
class MyClass:
    def __init__(self, name, age):
        self.name = name
        self.age = age

obj = MyClass("Alice", 30)
```

2. `__str__(self)`: 对象的字符串表示，可以通过 `str(obj)` 或 `print(obj)` 调用。作用是返回对象的描述信息，通常用于显示给用户。示例：

```python
class MyClass:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"My name is {self.name}"

obj = MyClass("Alice")
print(obj)  # 输出：My name is Alice
```

3. `__len__(self)`: 获取对象的长度，可以通过 `len(obj)` 调用。作用是返回对象的长度或元素个数。示例：

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

my_list = MyList([1, 2, 3, 4, 5])
print(len(my_list))  # 输出：5
```

4. `__getitem__(self, key)`: 获取对象的索引对应的值，可以通过 `obj[key]` 调用。作用是实现对象的索引访问。示例：

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __getitem__(self, index):
        return self.items[index]

my_list = MyList([1, 2, 3, 4, 5])
print(my_list[2])  # 输出：3
```

5. `__add__(self, other)`: 对象相加，可以通过 `obj1 + obj2` 调用。作用是实现对象的加法操作。示例：

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

point1 = Point(1, 2)
point2 = Point(3, 4)
result = point1 + point2
print(result.x, result.y)  # 输出：4 6
```

通过重写这些魔法函数，我们可以实现自定义的对象行为，使我们的类更具灵活性和扩展性。在实际应用中，根据类的需求，我们可以选择性地重写这些魔法函数来实现特定的功能。

<a name="apPcZ"></a>
## python is和==的区别
**答：**

- `is` 运算符用于判断两个对象是**否为同一个对象**（**引用同一个内存地址**）。
- `==` 运算符用于判断**两个对象的值是否相等**。

解释：<br />在Python中，`is` 和 `==` 是用于比较对象的两个不同运算符。

1.  `is` 运算符： 
   - `is` 运算符用于判断**两个对象**是否**引用同一个内存地址**，即判断两个对象**是否为同一个对象**。
   - 当两个对象的引用地址相同时，`is` 运算符返回 `True`，否则返回 `False`。
   - `is` 运算符比较的是对象的身份标识，即对象在内存中的地址，而不是对象的值。
2.  `==` 运算符： 
   - `==` 运算符用于判断两个对象的**值是否相等**，即判断两个对象的内容是否相同。
   - 当两个对象的值相同时，`==` 运算符返回 `True`，否则返回 `False`。
   - `==` 运算符比较的是对象的值，而不是对象的身份标识。

示例：
```python
# 创建两个相同值的整数对象
a = 42
b = 42

# 使用 is 运算符比较对象的身份标识
print(a is b)  # 输出：True，因为 a 和 b 引用同一个内存地址

# 使用 == 运算符比较对象的值
print(a == b)  # 输出：True，因为 a 和 b 的值相等
```

需要注意的是，对于小整数和字符串等常用的不可变对象，在Python中会进行缓存，使得相同值的对象在内存中只有一个实例。因此，在使用 `is` 运算符比较这些常用对象时，可能会得到 `True` 的结果。但对于大整数和其他自定义对象，由于没有缓存机制，相同值的对象不会共享内存地址，因此使用 `is` 运算符比较可能会得到 `False` 的结果。
<a name="npz6O"></a>
## i~~n 和 exist区别~~
**答：**

- `in` 操作符用于**检查一个值是否存在于一个容器中**。
- 不存在名为 `exist` 的操作符，可能是概念上的误解或误用。请注意使用正确的操作符以保证代码的正确性。

解释：<br />在Python中，`in` 和 `exist` 是两个不同的操作符，它们有不同的用途和语义。

1. `in` 操作符： 
   - `in` 操作符用于检查一个值是否存在于一个容器（如列表、元组、集合、字典等）中。
   - 当左操作数（值）存在于右操作数（容器）中时，`in` 操作符返回 `True`，否则返回 `False`。
   - `in` 操作符适用于所有可迭代的容器。

示例：

```python
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)  # 输出：True，因为 3 存在于列表中
print(6 in my_list)  # 输出：False，因为 6 不在列表中
```

2. `exist` 是您提到的操作符，但在Python中并不存在名为 `exist` 的操作符。可能是误解或误用了其他的操作符。

<a name="RO6Dv"></a>
## import之类的知识点
<a name="WrA6O"></a>
## python中import 和 from import的区别
**答：**

- `import` 用于**导入一个完整的模块**，**需要使用模块名访问其中的成员**。
- `from import` 用于**从一个模块中导入特定的成员**，可以直接使用这些成员而**不需要通过模块名访问**。
- 要根据实际情况选择合适的导入方式，以保持代码的可读性和易维护性。避免导入过多不必要的成员，以免引起命名冲突。

解释：<br />在Python中，`import` 和 `from import` 是用于导入模块或模块中的特定成员（函数、类、变量等）的两种不同方式。

1.  `import`: 
   - 使用 `import` 语句，可以将一个完整的模块导入到当前命名空间中。
   - 当使用 `import` 导入模块时，需要通过模块名访问其中的成员。
   - **优点是可以避免命名冲突**，模块的成员都在模块的命名空间中，**不会污染当前命名空间**。
   - 示例：
```python
import math
result = math.sqrt(16)
print(result)  # 输出：4.0
```
 

2.  `from import`: 
   - 使用 `from import` 语句，可以从一个模块中导入特定的成员到当前命名空间中。
   - 通过使用 `from import`，可以直接使用模块中的成员而不需要通过模块名访问。
   - 注意：**虽然方便，但要避免命名冲突，尽量不要在相同命名空间中导入多个模块**。
   - 示例：
```python
from math import sqrt
result = sqrt(16)
print(result)  # 输出：4.0
```

<a name="cmjYk"></a>
## 常用的Python的模块
以下是常用的Python标准库模块，它们提供了各种功能和工具，可帮助开发者更轻松地完成任务：

1. os: 提供与操作系统交互的功能，比如文件和目录操作。
2. sys: 提供对Python解释器的访问，以及与系统相关的配置和功能。
3. math: 提供数学运算函数。
4. random: 生成随机数。
5. datetime: 处理日期和时间的功能。
6. time: 提供时间相关的函数，如计时等。
7. json: 处理JSON数据的编码和解码。
8. csv: 读写CSV文件的功能。
9. re: 正则表达式库，用于处理文本匹配和搜索。
10. collections: 包含有用的集合类型，如deque、defaultdict等。
11. argparse: 解析命令行参数和选项。

<a name="CPY4O"></a>
## Python一个模块的加载过程
在Python中，模块是代码的组织单元，**可以将相关的代码放在一个模块中**，并通过 `import` 语句来加载和使用模块。模块的加载过程涉及以下几个步骤：

1.  **模块搜索路径**：当使用 `import` 语句导入模块时，Python解释器会根据一定的搜索路径来查找模块文件。搜索路径包括当前目录、Python标准库目录以及其他自定义目录。 
2. ** 编译模块**：如果找到模块文件，Python解释器会将模块的源代码编译为**字节码（.pyc）文件**，以提高后续加载速度。**编译后的字节码文件通常会保存在 **`**__pycache__**`** 目录中。** 
3.  **创建模块命名空间**：当模块被**导入时，Python会在内存中创建一个模块对象**，并**为该模块对象创建一个命名空间**。模块的全局变量和函数都存储在这个命名空间中。 
4.  **执行模块代码**：一旦模块的命名空间被创建，Python会执行模块的代码，将模块中定义的函数、类和变量等添加到模块的命名空间中。 
5.  **返回模块对象**：模块加载完成后，`import` 语句会返回模块对象，可以通过这个对象来访问模块中的内容。 

需要注意的是，**Python在导入模块时，会缓存已经导入的模块**，这样可以避免重复加载相同的模块，提高性能。**如果模块已经被加载过，再次导入时会直接使用已加载的模块对象**，而不会再重复执行模块的代码。<br />示例：<br />假设有一个名为 `my_module.py` 的模块文件，其中包含以下代码：
```python
# my_module.py

def say_hello():
    print("Hello from my_module!")

number = 42
```
然后在另一个Python脚本中，通过 `import` 语句加载该模块并使用其中的函数和变量：
```python
# main.py

import my_module

my_module.say_hello()
print(my_module.number)
```

在运行 `main.py` 脚本时，Python解释器会按照上述加载过程，加载 `my_module.py` 模块，并输出 "Hello from my_module!" 和 `42`。如果 `my_module.py` 模块已经加载过，再次导入时将直接使用已加载的模块对象，而不会重新执行模块代码。

<a name="WFtLI"></a>
## .pyc文件是起什么作用的？
.pyc 文件是 Python **编译后**的**字节码文件**，用于在解释器中执行 Python 程序。当你运行一个 Python 脚本（.py 文件）时，**Python 解释器会将源代码编译成字节码**，并将字节码保存到与脚本同名的 .pyc 文件中。<br />.pyc 文件的作用主要有两个：

1.  **提高执行性能**：由于 .pyc 文件是编译后的字节码，相比于源代码（.py 文件），它的加载和执行速度更快。Python 解释器在加载 .pyc 文件时可以直接执行字节码，无需再对源代码进行解析和编译，从而提高程序的执行性能。 
2.  **缓存编译结果**：Python 解释器在运行一个脚本时，**会检查是否存在对应的 .pyc 文件**。如果存在，则说明之前已经编译过该脚本，**而且源代码文件的修改时间没有发生变化，可以直接使用 .pyc 文件，而无需再次编译**。这样就**避免了重复的编译过程，提高了脚本的运行效率**。 

需要注意的是，.pyc 文件并不是必需的，Python 解释器可以在没有 .pyc 文件的情况下直接运行 .py 文件。如果你删除了 .pyc 文件，Python 解释器会重新生成它，或者在下一次运行脚本时自动重新编译生成新的 .pyc 文件。

.pyc 文件是平台无关的，你可以在不同平台（例如不同操作系统）上共享 .pyc 文件，只要 Python 版本和源代码是一致的。它们通常被保存在与脚本相同的目录下，并且文件名与 .py 文件相同，只是后缀为 .pyc。例如，如果有一个名为 `example.py` 的脚本，对应的 .pyc 文件将为 `example.pyc`。

<a name="Oexf0"></a>
## python中调用系统函数，应该怎么调用
在Python中调用系统函数可以使用标准库中的 `subprocess` 模块。`subprocess` 模块提供了创建和管理子进程的功能，允许你在Python中调用系统命令和执行外部程序。

有几种不同的函数可以用于调用系统函数，最常用的函数包括：

1. `**subprocess.run()**`**: 该函数可以运行一个系统命令，并等待命令执行完成后返回结果。示例：**
```python
import subprocess

result = subprocess.run(["ls", "-l"], capture_output=True, text=True)
print(result.stdout)
```

2. `subprocess.Popen()`: 该函数用于创建一个子进程，你可以使用它的方法来与子进程进行交互。示例：
```python
import subprocess

process = subprocess.Popen(["ping", "google.com"], stdout=subprocess.PIPE, text=True)
output, _ = process.communicate()
print(output)
```

3. `**os.system()**`**: 这是一个较旧的方法，**它**会在操作系统中运行一个命令**，并且不提供很多的灵活性。不过简单的系统命令可以使用它。示例：
```python
import os

os.system("ls -l")
```
注意：在调用系统函数时，尽量避免直接将用户输入作为命令参数，以防止安全漏洞。应该使用安全的方式传递参数，例如使用 `subprocess.run()` 中的 `args` 参数，或者使用 `shlex.quote()` 函数对参数进行转义。
<a name="cLR0M"></a>
## 删除列表的空元素有哪些方法
有多种方法可以删除列表中的空元素，下面介绍几种常见的方法：

1. 使用列表推导式：<br />可以使用列表推导式来创建一个新的列表，其中排除原列表中的空元素。
```python
my_list = [1, 2, '', 3, '', 4, '']
new_list = [item for item in my_list if item != '']
print(new_list)
```

2. 使用 filter() 函数：<br />可以使用 `**filter()**`** 函数，它会根据提供的函数对列表进行筛选，过滤掉空元素。**
```python
my_list = [1, 2, '', 3, '', 4, '']
new_list = list(filter(lambda x: x != '', my_list))
print(new_list)
```

3. 使用循环遍历：<br />可以使用循环遍历原列表，将空元素排除，然后添加到新列表中。
```python
my_list = [1, 2, '', 3, '', 4, '']
new_list = []
for item in my_list:
    if item != '':
        new_list.append(item)
print(new_list)
```

4. 使用列表的 `remove()` 方法：<br />可以使用列表的 `remove()` 方法，循环删除列表中的空元素。
```python
my_list = [1, 2, '', 3, '', 4, '']
while '' in my_list:
    my_list.remove('')
print(my_list)
```

请注意，以上方法中，第一种和第二种方法会创建一个新的列表，原始列表不受影响。而第三种和第四种方法会直接在原列表上进行操作，所以需要小心处理，以避免意外删除其他元素。根据实际情况，选择合适的方法来删除列表中的空元素。
<a name="evtq4"></a>
## 不可变元素和可变元素的区别（可变对象和不可变对象）
**答：**

- 不可变元素在创建后其值不可修改，**修改操作会创建一个新的对象。**
- 可变元素在创建后其值可以被修改，**而不会创建新的对象**。

解释：<br />不可变元素（Immutable）和可变元素（Mutable）是在Python中用于描述对象特性的概念。

1. 不可变元素（Immutable）： 
   - 不可变元素指的是对象创建后其值不能被修改的元素。
   - 不可变元素在创建后，其值不可变，任何修改操作都会创建一个新的对象。
   - 常见的不可变元素有整数（int）、浮点数（float）、字符串（str）、元组（tuple）等。
   - 不可变元素在内存中的值是固定的，无法通过修改操作来改变它的值。

示例：
```python
x = 5  # 整数是不可变元素
y = "hello"  # 字符串是不可变元素
z = (1, 2, 3)  # 元组是不可变元素

# 试图修改不可变元素的值将会引发错误
# x[0] = 10  # 报错：TypeError: 'int' object does not support item assignment
# y[0] = 'H'  # 报错：TypeError: 'str' object does not support item assignment
# z[0] = 100  # 报错：TypeError: 'tuple' object does not support item assignment
```

2. 可变元素（Mutable）： 
   - 可变元素指的是对象创建后其值可以被修改的元素。
   - 可变元素在创建后，其值可以随时修改，而不会创建新的对象。
   - 常见的可变元素有列表（list）、字典（dict）、集合（set）等。
   - 可变元素在内存中的值可以通过修改操作来改变。

示例：
```python
a = [1, 2, 3]  # 列表是可变元素
b = {'name': 'Alice', 'age': 30}  # 字典是可变元素

a.append(4)  # 修改列表，添加新元素
b['age'] = 31  # 修改字典的值

print(a)  # 输出：[1, 2, 3, 4]
print(b)  # 输出：{'name': 'Alice', 'age': 31}
```
<a name="JTlGd"></a>
## 整型变量为什么是不可变对象
整型变量在Python中是不可变对象，这是出于**设计和实现**的考虑。主要有以下几个原因：

1.  **一致性和可预测性**：不可变对象的值在创建后不可改变，这保证了整型变量的一致性和可预测性。如果整型变量是可变的，那么修改它的值可能会导致意外的行为和错误，不易于程序的理解和调试。 
2.  **效率**：不可变对象的值不可变，这使得Python可以在内部对整型对象进行优化。例如，对于较小的整数，Python可以使用整数池来重用相同的对象，从而节省内存和提高性能。 
3.  **哈希值**：不可变对象可以用作字典的键，因为它们的哈希值在创建后不会改变。如果整型是可变的，那么它的哈希值会随着值的改变而改变，导致不再适合作为字典的键。 
4.  **线程安全**：不可变对象在多线程环境下更容易维护，因为它们的值不会发生改变，不需要额外的同步措施。 

综上所述，将整型变量设计为不可变对象是为了保证代码的一致性、可预测性和高效性，同时增加了代码的可靠性和安全性。在实际编程中，应该充分利用整型的不可变性，并避免对整型变量进行不必要的修改。
<a name="dhE1y"></a>
## python去重方法及原理
set、dict
<a name="sWf8e"></a>
### list去重怎么去，不能用set

1. set
2. 列表推导式 `unique_list = [x for i, x in enumerate(original_list) if x not in original_list[:i]]`
3. 使用**dict.fromkeys()函数**`list(dict.fromkeys(original_list))`
4. 使用collections.OrderedDict()`list(OrderedDict.fromkeys(original_list))`

<a name="F4OLO"></a>
### list如何快速去重？
set最快、dict.fromkeys()次之。但是fromkeys()可以保持插入顺序。
<a name="k2JIy"></a>
## python bool类型为false的有哪些？

1. False 常量：布尔类型的False常量，表示逻辑上的假。
2. None 常量：表示空值或缺失值。
3.  0 和 0.0：整数0和浮点数0。
4. 空的序列：空字符串、空列表、空元组等。
5. 空的映射：空字典。
6. 自定义类的实例：当类定义了 **__bool__() **或 **__len__() **方法，并且**返回0或False时**，类的实例也会被视为False。
<a name="fKXe4"></a>
## python给定一个变量如何判断它的类型
内置函数 type()
<a name="iBmf7"></a>
## python 如何合并两个list

1. +操作符
2. extend()方法
3. for + append()

<a name="qcBkr"></a>
## list插入有几种方式
在Python中，列表（list）提供了多种方式来插入元素。以下是常见的几种插入方式：

1. 使用 `append()` 方法：<br />`append()` 方法用于在列表的末尾添加一个元素。
```python
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)  # 输出：[1, 2, 3, 4]
```

2. 使用 `insert()` 方法：<br />`insert()` 方法用于在指定位置插入一个元素，指定位置的索引作为第一个参数。
```python
my_list = [1, 2, 3]
my_list.insert(1, 4)
print(my_list)  # 输出：[1, 4, 2, 3]
```

3. 使用切片赋值：<br />利用切片赋值的方式可以在指定位置插入多个元素。
```python
my_list = [1, 2, 3]
my_list[1:1] = [4, 5]
print(my_list)  # 输出：[1, 4, 5, 2, 3]
```

4. 使用 `extend()` 方法：<br />`extend()` 方法用于在列表末尾添加多个元素，参数是一个可迭代对象（如列表、元组或字符串）。
```python
my_list = [1, 2, 3]
my_list.extend([4, 5])
print(my_list)  # 输出：[1, 2, 3, 4, 5]
```

这些都是常见的列表插入方式，你可以根据具体需求选择合适的方式来插入元素。需要注意的是，`append()` 和 `extend()` 方法会直接修改原列表，而 `insert()` 方法和切片赋值会在原列表上进行插入操作。
<a name="veorq"></a>
## 怎么移除列表里面的内容，remove del pop，考点是remove
在Python中，移除列表中的内容可以使用 `remove()`、`del` 和 `pop()` 方法。考点是 `remove()` 方法，它用于移除列表中第一个出现的指定元素。

1. 使用 `remove()` 方法：<br />`remove()` 方法**用于移除列表中第一个出现的指定元素**。
```python
my_list = [1, 2, 3, 2]
my_list.remove(2)
print(my_list)  # 输出：[1, 3, 2]
```
remove() 方法是列表（list）的特定方法，用于移除列表中指定的元素。它只能在列表上调用，不能直接用于其他类型的数据结构，例如集合（set）或字典（dict）。

2. 使用 `del` 关键字：<br />`del` 关键字用于删除列表中指定位置的元素。
```python
my_list = [1, 2, 3, 4]
del my_list[1]
print(my_list)  # 输出：[1, 3, 4]
```

3. 使用 `pop()` 方法：<br />`pop()` 方法用于移除列表中指定位置的元素，并返回该元素的值。
```python
my_list = [1, 2, 3, 4]
value = my_list.pop(1)
print(my_list)  # 输出：[1, 3, 4]
print(value)  # 输出：2
```
需要注意的是，`remove()` 方法只移除第一个出现的指定元素，**如果列表中有多个相同的元素，只有第一个会被移除。**而 `del` 关键字和 `pop()` 方法**可以根据索引来指定要移除的元素**，可以移除指定位置上的任意元素。<br />在实际使用时，根据需要选择适合的方法来移除列表中的内容。
<a name="ZtPma"></a>
## 列表b=列表a，修改b之后，a如何（Python的拷贝机制）
**答：当修改列表B的内容时，由于列表A和列表B指向同一个列表对象，列表A的内容也会随之改变。这种赋值方式在其他可变数据类型上也是一样的。**<br />在Python中，列表的赋值操作实际上是将列表的引用复制给新的变量，而不是创建一个新的独立副本。所以当你通过赋值将列表A赋给列表B，实际上列表A和列表B都指向同一个列表对象，它们共享相同的数据。<br />示例：
```python
list_a = [1, 2, 3]
list_b = list_a

print(list_a)  # 输出：[1, 2, 3]
print(list_b)  # 输出：[1, 2, 3]

list_b.append(4)
print(list_a)  # 输出：[1, 2, 3, 4]
print(list_b)  # 输出：[1, 2, 3, 4]

list_a[0] = 100
print(list_a)  # 输出：[100, 2, 3, 4]
print(list_b)  # 输出：[100, 2, 3, 4]
```

如上例所示，当通过`list_b.append(4)`将4添加到列表B时，列表A也被修改了。而当通过`list_a[0] = 100`修改列表A的第一个元素时，列表B也随之改变。

如果你希望得到两个相互独立的列表，需要使用切片或其他的拷贝方法，例如使用`list_b = list_a[:]`来创建一个列表B的副本，这样列表A和列表B将是两个独立的列表对象，修改其中一个列表不会影响另一个。
<a name="IjJsr"></a>
## python中的数组
在Python中，数组是一种用来存储多个元素的数据结构，可以包含不同类型的元素。Python中提供了多种实现数组的方式，常见的有以下几种：

1. 列表（List）：<br />列表是Python内置的一种数据结构，可以用来存储多个元素，支持不同类型的元素，长度可以动态变化。列表使用方括号 `[]` 定义，可以通过索引访问和修改元素。

```python
my_list = [1, 2, 3, "hello", True]
```

2. **数组模块（array）**：<br />Python的数组模块提供了一种更加紧凑的数组实现，可以用来存储同类型的元素，**数组的长度固定，创建后不能改变。需要先导入数组模块。**
```python
import array

my_array = array.array('i', [1, 2, 3, 4, 5])
```

3. NumPy数组：<br />NumPy是Python中用于科学计算的一个强大库，提供了多维数组对象（ndarray），用于高效处理大量数据。NumPy数组的操作速度非常快，支持向量化运算。

```python
import numpy as np

my_numpy_array = np.array([1, 2, 3, 4, 5])
```

在实际应用中，通常使用列表更为常见，因为它具有灵活性，支持不同类型的元素，并且长度可以动态变化。而数组模块和NumPy数组适用于特定的需求，例如需要处理大量同类型数据或进行科学计算时。
<a name="It2Dr"></a>
## 数组和list实现原理有什么不同
在Python中，数组（array）和列表（list）虽然都可以用来存储多个元素，但它们在实现原理和特性上有一些不同。

1.  实现原理： 
   - **列表（List）是Python的内置数据类型，**实际上是一种**动态数组**，用于存储多个元素。列表的**底层实现是动态数组**，通过动态数组存储元素，**但这也导致列表的访问速度不如数组。**
   - **数组（Array）是Python标准库中的数据结构模块**，需要通过 `import array` 来使用。数组是一种紧凑的数据结构，用于存储同类型的元素。数组的底层实现是C语言数组，因此效率比列表更高，但它的大小固定，创建后不能动态调整。
2.  存储类型： 
   - 列表（List）：可以存储不同类型的元素，例如整数、浮点数、字符串、布尔值等。
   - 数组（Array）：需要在创建时指定存储的数据类型，只能存储同类型的元素，例如整数、浮点数等。
3.  动态调整： 
   - 列表（List）：支持动态大小调整，可以随时添加或删除元素。
   - 数组（Array）：创建后大小固定，不能动态调整，需要预先指定大小。

示例：
```python
# 列表
my_list = [1, 2, 3, "hello", True]

# 数组
import array
my_array = array.array('i', [1, 2, 3, 4, 5])
```
在实际应用中，如果需要存储不同类型的元素，或者需要频繁地进行插入和删除操作，可以使用列表。而如果需要存储大量同类型的元素，并且希望获得更高的访问速度，可以考虑使用数组。另外，如果需要进行科学计算或者处理大规模数据，可以使用NumPy数组，它提供了更多高级的数学和科学函数。
<a name="HGm1P"></a>
## Python的作用域
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28187560/1691310691320-73c280b0-abef-4fb9-8132-3a46d3230e3f.png#averageHue=%23d5e2d6&clientId=u7d3bc469-8e42-4&from=paste&height=190&id=u8feb6d3b&originHeight=380&originWidth=640&originalType=binary&ratio=2&rotation=0&showTitle=false&size=110678&status=done&style=none&taskId=u663d5015-07f3-4299-a59c-4136df71e06&title=&width=320)
<a name="tnSzI"></a>
### 1. 全局作用域（Global Scope）：

- 全局作用域是在代码中任何函数、类或语句块之外定义的变量和函数的作用域。
- 在全局作用域中定义的变量可以在代码的任何位置访问。

<a name="pSY5J"></a>
### 2. 局部作用域（Local Scope）：

- 局部作用域是在**函数或语句块内部定义的变量和函数的作用域**。
- 在**局部作用域**中定义**的变量**只能在所在的函数或语句块内部访问。
- 局部作用域中可以修改外部的变量吗？**可以！**前提是这些变量是**可变类型（如列表、字典等）**，而不是不可变类型（如数字、字符串、元组等）。
<a name="w8gFo"></a>
### 3. 嵌套作用域（Enclosing Scope）：

- 嵌套作用域是指在一个函数**内部定义的另一个函数的作用域**。
- **在嵌套作用域中，内部函数可以访问外部函数中的变量。**
- 示例：

```python
def outer_function():
    outer_var = 30  # 外部函数的变量

    def inner_function():
        print(outer_var)  # 在内部函数中访问外部函数的变量

inner_function()

outer_function()  # 输出: 30
```

<a name="SK3gI"></a>
### 4. 内置作用域（Built-in Scope）：

- 内置作用域是 Python 内置的函数和变量的作用域。
- **在任何地方都可以访问内置作用域中的函数和变量，无需导入任何模块。**
- 示例：
```python
print(len([1, 2, 3]))  # 使用内置作用域中的函数len()
```

<a name="OBVXs"></a>
## Python如何取地址（内存管理）
在Python中，**可以使用内置函数 **`**id()**`** 来获取对象的内存地址**。该函数**返回一个整数**，表示对象在内存中的唯一地址。需要注意的是，`id()` 函数**返回的是对象的身份标识符（identity）**，不同对象的身份标识符是唯一且不变的，但相同值的对象可能具有相同的身份标识符。<br />示例：
```python
# 整数
x = 10
print(id(x))  # 输出：140732352665600

# 列表
my_list = [1, 2, 3]
print(id(my_list))  # 输出类似：140732350999168

# 字符串
my_str = "Hello"
print(id(my_str))  # 输出类似：140732350961984
```
需要注意的是，不同运行时和不同的机器上，相同值的对象的内存地址可能是不同的。Python解释器会根据对象的值和内存管理的规则来决定对象的内存地址分配方式。因此，**不能依赖于 **`**id()**`** 函数的结果来进行对象之间的比较或判断相等性。正确的比较对象值是否相等应该使用 **`**==**`** 运算符。**<br />**内存管理在Python中是由解释器自动完成的**，它负责对象的内存分配和释放，以及垃圾回收等操作，这样开发者无需手动管理内存，让开发变得更加简单和高效。
<a name="Ws6Ym"></a>
## python内存管理（内存池，垃圾回收机制，不了解的赶紧去查，高频）
<a name="HtoqW"></a>
### 说说python如何内存管理

1. **引用计数**：**python内部使用引用计数，来保持追踪内存中的对象**，Python**内部记录了对象有多少个引用**，**即引用计数**，当**对象被创建时就创建了一个引用计数**，当**对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。**
2. **垃圾回收**：python**会检查引用计数为0的对象**，清除其在内存占的空间；**循环引用对象则用一个循环垃圾回收器来回收**
3. **内存池机制**：**内存池在Python解释器启动时就会被初始化**，它会**预先分配一块较大的内存空间**，**并将其切分成固定大小的小块**，**这些小块称为内存池块**。然后，**当程序中需要分配内存时，Python会直接从内存池中获取预先分配的小块，而不是直接向操作系统请求内存**。这样做的好处是避免了频繁地向操作系统申请和释放内存，提高了内存分配和释放的效率。
   - a) Python提供了对内存的**垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。**
   - b) Python中**所有小于256个字节的对象都使用pymalloc实现的分配器**，**而大的对象则使用系统的 malloc**。另外**Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。**也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
   - 线程局部：每个线程都有自己的内存池，避免了多线程环境下的内存竞争问题。
<a name="qElhR"></a>
#### 引用计数何时 -1 （不再引用对象，引用次数减少）

1. 变量重新赋值
2. 超出作用域（函数结束）
3. del删除变量
4. 变量=None
<a name="QHe0C"></a>
## 简单说明一下python中的垃圾回收机制(GC回收机制)
（自动处理分配回收内存的问题，没用了内存泄漏的隐患），以引用计数机制为主，标记-清楚和分代收集两种机制为辅<br />计数机制就是python中的每一个对象都有一个引用计数的值，当有引用的时候，这个值会增加，引用他的对象被删除时，这个值减小，引用计数的值为0时，该对象生命结束，python会把这段内存自动回收。（缺点，循环引用，如果l1和l2相互引用，没用其他的对象引用他们，这两段内存永远无法被回收）
<a name="Q1DX4"></a>
## python内存池
Python的内存池是内存管理技术的一种，是用来提高Python程序的内存分配和释放效率的。<br />**内存池在Python解释器启动时就会被初始化**，它会**预先分配一块较大的内存空间**，**并将其切分成固定大小的小块**，**这些小块称为内存池块**。然后，**当程序中需要分配内存时，Python会直接从内存池中获取预先分配的小块，而不是直接向操作系统请求内存**。这样做的好处是避免了频繁地向操作系统申请和释放内存，提高了内存 分配和释放的效率。

- a) Python提供了对内存的**垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。**
- b) Python中**所有小于256个字节的对象都使用pymalloc实现的分配器**，**而大的对象则使用系统的 malloc**。另外**Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。**也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
- 线程局部：每个线程都有自己的内存池，避免了多线程环境下的内存竞争问题。
<a name="ncml7"></a>
## python2与pythin3区别
Python 2 和 Python 3 是两个主要版本的 Python 编程语言。Python 3 是对 Python 2 的改进和升级，引入了许多新特性和语法，同时也修复了一些旧版本的缺陷。以下是 Python 2 和 Python 3 之间的一些主要区别：

1. Print 语句：
- Python 2：使用 `print` 作为语句进行打印。
- Python 3：使用 `print()` 作为函数进行打印，必须加上括号。

Python 2 代码示例：
```python
print "Hello, Python 2!"
```

Python 3 代码示例：
```python
print("Hello, Python 3!")
```

2. 整数除法：
- Python 2：整数除法返回整数结果，即使结果是小数也会被截断成整数。
- Python 3：**整数除法返回浮点数结果。**

Python 2 代码示例：
```python
result = 5 / 2   # 结果为 2
```
Python 3 代码示例：
```python
result = 5 / 2   # 结果为 2.5
```

3. Unicode 字符串：
- Python 2：默认**字符串类型是 ASCII 字符串，要使用 Unicode 字符串需要在字符串前加上 **`**u**`** 前缀。**
- Python 3：默认**字符串类型是 Unicode 字符串**，普通字符串要在字符串前加上 `b` 前缀。

Python 2 代码示例：
```python
unicode_str = u"Hello, Unicode!"
```
Python 3 代码示例：
```python
unicode_str = "Hello, Unicode!"
```

4. xrange() vs range()：
- Python 2：使用 `xrange()` **生成一个 xrange 对象，它是一个迭代器，用于节省内存。**
- Python 3：将 `xrange()` 合并到 `range()` 中，只保留 `range()` 函数，它返回一个类似 Python 2 中的 `xrange()` 迭代器。

Python 2 代码示例：
```python
for i in xrange(5):
    print(i)
```
Python 3 代码示例：
```python
for i in range(5):
    print(i)
```

5. input() vs raw_input()：
- Python 2：`input()` 函数会将输入当作 Python 代码进行解析，因此会导致安全问题。
- Python 3：`raw_input()` 被移除，`input()` 等同于 Python 2 中的 `raw_input()`，不再解析输入。

Python 2 代码示例：
```python
name = input("Enter your name: ")
```
Python 3 代码示例：
```python
name = input("Enter your name: ")
```

除了上述的主要区别之外，Python 3 还进行了一些其他改进和优化，例如对于字节串和字符串的处理、编码、异常处理等方面都有不同。这些改进使得 Python 3 更加现代化、易读和易维护，因此推荐新项目使用 Python 3，而现有项目也逐渐考虑迁移到 Python 3 上来。
<a name="Hy2Tx"></a>
## Python里边抽象的概念？
在Python中，抽象是指将**具体的实现细节与接口分离**，将关注点放在对象或函数的行为和功能上，而不是其具体实现。抽象是一种编程范式，它通过隐藏实现细节和暴露必要的接口，让开发者可以更容易地理解和使用代码，同时也提高了代码的可维护性和可扩展性。

Python中的抽象主要体现在以下几个方面：

1. 抽象类（Abstract Classes）：抽象类是一种特殊的类，它不能直接被实例化，只能被继承。抽象类**通常定义了一个或多个抽象方法（没有实现的方法）**，**子类必须实现这些抽象方法才能被实例化。**Python中**可以使用**`**abc**`**（Abstract Base Classes）模块来定义抽象类**。

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

circle = Circle(5)
print(circle.area())  # 输出 78.5
```

2.  接口（Interfaces）：在Python中，没有严格的接口定义，但可以通过抽象类和多态实现类似接口的概念。**接口是一组方法签名（方法名和参数列表）**，子类可以根据接口定义来实现自己的方法。 
3.  抽象函数（Abstract Functions）：Python中没有直接支持抽象函数的特性，但可以使用抽象类和抽象方法来模拟抽象函数的概念。抽象函数是一种没有实现的函数，只有函数签名（函数名和参数列表），子类必须实现这些抽象函数才能被实例化。 
4.  面向对象编程（Object-Oriented Programming）：面向对象编程本身就是一种抽象的概念，它将数据和操作封装在对象中，并通过类的继承和多态来实现代码的抽象和复用。 
5.  Duck Typing：Python是一种动态类型语言，它支持鸭子类型（Duck Typing）的概念。**鸭子类型是一种在运行时判断对象是否具有特定方法或行为的方式，而不是通过继承或接口的方式。这种灵活的类型判断使得Python可以更自由地进行抽象和多态。 **

抽象的概念在Python中非常重要，它使得代码更具灵活性和可扩展性，同时也让代码更易于理解和维护。通过抽象，开发者可以关注于代码的设计和功能，而不必过多关心实现细节。
<a name="X6r0a"></a>
## python反射机制
Python的反射机制是指**在运行时通过字符串的形式**来**访问**、**修改**或**调用对象的属性、方法、类**等。这种机制使得Python代码更加灵活和动态，可以在运行时根据需要进行对象的操作，而无需在编译时明确指定。<br />Python中的**反射机制**主要涉及以下三个内置函数：

1. **getattr**(obj, name[, default])：用于获取对象的属性。它接受一个对象 `obj` 和属性名 `name`，如果对象有该属性，则返回属性值；如果对象没有该属性，则可选地返回默认值 `default`（如果提供了）。
```python
class MyClass:
    def __init__(self):
        self.x = 10

obj = MyClass()
attr_value = getattr(obj, 'x')
print(attr_value)  # 输出 10

attr_value = getattr(obj, 'y', 'default_value')
print(attr_value)  # 输出 'default_value'，因为对象没有属性 y
```

2. **setattr**(obj, name, value)：用于设置对象的属性。它接受一个对象 `obj`、属性名 `name` 和属性值 `value`，将属性名指定的属性设置为给定的值。
```python
class MyClass:
    def __init__(self):
        self.x = 10

obj = MyClass()
setattr(obj, 'x', 20)
print(obj.x)  # 输出 20

setattr(obj, 'y', 30)
print(obj.y)  # 输出 30，对象的属性 y 被动态添加
```

3. **delattr**(obj, name)：用于删除对象的属性。它接受一个对象 `obj` 和属性名 `name`，如果对象有该属性，则删除该属性。
```python
class MyClass:
    def __init__(self):
        self.x = 10

obj = MyClass()
delattr(obj, 'x')
print(hasattr(obj, 'x'))  # 输出 False，对象的属性 x 被删除
```

除了**使用内置函数实现反射**，Python还提供了一些内置函数和方法，如`hasattr()`、`isinstance()`、`issubclass()`等，可以检查对象是否具有某个属性或方法，或者某个对象是否是某个类的实例。<br />反射机制使得Python具有强大的动态性，但也需要谨慎使用，因为过度使用反射可能导致代码不易维护和理解。在使用反射时，应该确保操作合法，避免出现意外错误。

<a name="io5BV"></a>
### hasattr()
`hasattr()` 是 Python 内置函数之一，用于检查一个对象是否具有指定的属性或方法。它接受两个参数：要检查的对象和一个字符串，表示属性名或方法名。如果对象有该属性或方法，`hasattr()` 返回 True，否则返回 False。<br />语法：
```python
hasattr(object, name)
```

参数说明：

- `object`：要检查的对象。
- `name`：属性名或方法名，是一个字符串。

使用 `hasattr()` 函数可以在运行时动态地检查对象的属性或方法，这对于编写灵活的代码和处理未知对象非常有用。例如，你可以在使用反射机制时，先使用 `hasattr()` 检查对象是否有特定的属性或方法，然后再根据结果决定是否进行后续的操作。

示例：
```python
class MyClass:
    def __init__(self):
        self.x = 10

    def my_method(self):
        print("This is a method.")

obj = MyClass()

# 检查对象是否具有属性或方法
print(hasattr(obj, 'x'))           # 输出 True
print(hasattr(obj, 'my_method'))   # 输出 True
print(hasattr(obj, 'y'))           # 输出 False，对象没有属性或方法 y
```
注意：`hasattr()` 只是检查属性或方法是否存在，它不会验证属性或方法是否可以被访问或调用。如果对象具有某个属性或方法，但由于访问权限或其他原因而无法访问，`hasattr()` 仍然会返回 True。在使用具有访问权限限制的属性或方法时，应该使用 `getattr()` 来获取属性或方法，并处理 `AttributeError` 异常来确保操作的合法性。
<a name="onrDc"></a>
### issubclass(clsA, [tuple, classB])
clsA是否是[tuple, classB]的子类。若是元组，有一个满足就是True。

<a name="bZLMX"></a>
## 栈和队列的概念以及分别的特点
栈（Stack）和队列（Queue）都是在计算机科学中常见的数据结构，用于存储和操作数据。它们有着不同的特点和用途：

1.  栈（Stack）： 
   - 概念：栈是一种后进先出（Last In First Out，LIFO）的数据结构。最后放入栈的元素将首先被取出，即最后进栈的元素会先出栈。
   - 特点： 
      - 只能在栈顶（顶部）进行插入和删除操作。
      - 新元素进入栈顶，而旧元素离开栈顶。
      - 插入操作称为“入栈”（push），删除操作称为“出栈”（pop）。
   - 用途：栈常用于表达式求值、函数调用、内存管理和回退操作等场景。
2.  队列（Queue）： 
   - 概念：队列是一种先进先出（First In First Out，FIFO）的数据结构。最先进入队列的元素将首先被取出，即最先入队列的元素会先出队列。
   - 特点： 
      - 只能在队列的一端（队尾）进行插入操作，称为“入队”（enqueue）。
      - 只能在队列的另一端（队首）进行删除操作，称为“出队”（dequeue）。
      - 新元素进入队尾，而最旧元素离开队首。
   - 用途：队列常用于任务调度、缓冲区、广度优先搜索等场景。

在 Python 中，可以使用列表（List）来实现栈和队列的基本功能。例如，使用 `append()` 和 `pop()` 方法可以将列表作为栈使用，使用 `append()` 和 `pop(0)` 方法可以将列表作为队列使用。

示例：使用列表实现栈和队列

```python
# 栈（LIFO）
stack = []
stack.append(1)  # 入栈
stack.append(2)
stack.append(3)
print(stack.pop())  # 出栈，输出 3
print(stack.pop())  # 出栈，输出 2

# 队列（FIFO）
queue = []
queue.append(1)  # 入队
queue.append(2)
queue.append(3)
print(queue.pop(0))  # 出队，输出 1
print(queue.pop(0))  # 出队，输出 2
```

需要注意的是，Python中还有专门的模块实现栈和队列，如 `queue` 模块中的 `Queue` 类，以及第三方库如 `collections.deque` 类，它们提供更高效和功能更全面的栈和队列实现。
<a name="cQgZI"></a>
### 如何用队列实现栈？
可以使用队列来实现栈的基本功能，即后进先出（Last In First Out，LIFO）的特性。为了将队列转换为栈，我们可以借助两个队列，一个主队列和一个辅助队列，以实现栈的 push（入栈）和 pop（出栈）操作。

下面是用队列实现栈的 Python 示例代码：

```python
from collections import deque

class StackUsingQueue:
    def __init__(self):
        self.main_queue = deque()
        self.helper_queue = deque()

    def push(self, value):
        # 将新元素放入辅助队列
        self.helper_queue.append(value)

        # 将主队列中的所有元素移动到辅助队列中
        while self.main_queue:
            self.helper_queue.append(self.main_queue.popleft())

        # 交换主队列和辅助队列，使得主队列始终为空队列
        self.main_queue, self.helper_queue = self.helper_queue, self.main_queue

    def pop(self):
        if not self.main_queue:
            return None  # 栈为空

        return self.main_queue.popleft()

    def is_empty(self):
        return len(self.main_queue) == 0

# 示例使用
stack = StackUsingQueue()
stack.push(1)
stack.push(2)
stack.push(3)

print(stack.pop())  # 输出 3
print(stack.pop())  # 输出 2

stack.push(4)
print(stack.pop())  # 输出 4
print(stack.pop())  # 输出 1

print(stack.is_empty())  # 输出 True，栈为空
```

在这个实现中，push（入栈）操作的时间复杂度是 O(n)，其中 n 是栈中元素的数量。pop（出栈）操作的时间复杂度是 O(1)。虽然这种实现不是最高效的，但它可以用队列来模拟栈的功能。如果对时间复杂度有更高要求，可以使用其他数据结构来实现栈，例如使用链表来实现一个高效的栈。
<a name="b71sC"></a>
### 如何用栈实现队列？
class QueueUsingStack:<br />def **init**(self):<br />self.enqueue_stack = []  # 入队栈<br />self.dequeue_stack = []  # 出队栈

```
def enqueue(self, value):
    # 直接将元素入队入入队栈
    self.enqueue_stack.append(value)

def dequeue(self):
    if not self.dequeue_stack:
        # 当出队栈为空时，将入队栈的元素转移到出队栈中
        while self.enqueue_stack:
            self.dequeue_stack.append(self.enqueue_stack.pop())

    if not self.dequeue_stack:
        return None  # 队列为空

    return self.dequeue_stack.pop()

def is_empty(self):
    return len(self.enqueue_stack) == 0 and len(self.dequeue_stack) == 0
```

<a name="TDrBx"></a>
## python实现循环队列
在 Python 中实现循环队列可以使用列表（List）作为底层数据结构，通过适当的处理来实现队列的循环性质。循环队列中的队尾和队首在逻辑上是相邻的，并且当队列满时可以重新利用之前出队的空间。
```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0     # 队首指针
        self.rear = -1     # 队尾指针
        self.size = 0      # 当前队列中元素数量

    def is_empty(self):
        return self.size == 0

    def is_full(self):
        return self.size == self.capacity

    def enqueue(self, value):
        if self.is_full():
            print("Queue is full. Cannot enqueue.")
            return

        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = value
        self.size += 1

    def dequeue(self):
        if self.is_empty():
            print("Queue is empty. Cannot dequeue.")
            return None

        value = self.queue[self.front]
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return value

    def peek(self):
        if self.is_empty():
            print("Queue is empty.")
            return None

        return self.queue[self.front]

    def print_queue(self):
        if self.is_empty():
            print("Queue is empty.")
        else:
            index = self.front
            for i in range(self.size):
                print(self.queue[index], end=" ")
                index = (index + 1) % self.capacity
            print()

# 示例使用
queue = CircularQueue(5)
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
queue.enqueue(4)
queue.enqueue(5)

queue.print_queue()  # 输出 1 2 3 4 5

queue.dequeue()
queue.dequeue()

queue.enqueue(6)
queue.enqueue(7)

queue.print_queue()  # 输出 3 4 5 6 7

```

<a name="hOKnu"></a>
## 数组和链表，数组以及链表在内存开辟的空间是连续的吗？需要确定长度大小吗？谁查询快？
数组（Array）和链表（Linked List）都是常见的数据结构，它们在内存中的开辟空间方式是不同的。

1.  数组（Array）： 
   - 内存空间：数组在内存中是连续的，即数组的元素在内存中按照顺序依次存储在连续的内存地址上。
   - 长度大小：在大多数编程语言中，数组的长度是固定的，需要在创建数组时指定长度。长度通常在创建后不能改变。
   - 查询速度：数组的查询速度很快，可以通过索引直接访问任意位置的元素，时间复杂度为 O(1)。因为数组是连续存储的，通过索引计算元素的内存地址可以在常数时间内完成。
2.  链表（Linked List）： 
   - 内存空间：链表中的节点在内存中可以是分散的，即链表的每个节点在内存中可能存储在不同的地址上。每个节点除了存储自己的数据外，还包含一个指向下一个节点的指针（单向链表）或者同时包含指向前一个节点的指针（双向链表）。
   - 长度大小：链表的长度是可以动态变化的，可以根据需要动态添加或删除节点，因此不需要在创建链表时确定长度大小。
   - 查询速度：链表的查询速度较慢，因为它不像数组可以通过索引直接访问元素，而是需要从头节点开始逐个遍历链表，直到找到目标元素。链表的查询时间复杂度为 O(n)，其中 n 是链表的长度。最坏情况下，需要遍历整个链表才能找到目标元素。

综合来看，**在查询速度方面，数组比链表快，因为数组支持通过索引直接访问元素，而链表需要遍历查找。**但是在插入和删除操作方面，链表比数组更灵活，因为链表的节点可以动态添加和删除，而数组长度固定，插入和删除操作可能需要进行元素的移动。<br />选择使用数组还是链表取决于具体的应用场景和操作需求。如果需要频繁的随机访问和已知固定大小的集合，数组是一个不错的选择。如果需要频繁的插入和删除操作，并且集合大小可能动态变化，链表则更加合适。
<a name="RenZP"></a>
## 拼接字符串有哪几种方式

1. +
2. .join()
3. f""
4. str.format()
5. {0}, {1}, {0} str.format(0, 1)
6. {a}, {b} str.format(a='', b='')

<a name="v5oaA"></a>
## Python里边global全局变量有了解吗？
在Python中，**global关键字用于声明函数内部的变量应该引用与同名的全局变量**，**而不是创建一个新的局部变量**。当你在函数内部修改一个变量时，Python默认将其视为局部变量。但是如果你想在函数内部修改全局变量，就需要使用global关键字。

下面是一个示例来演示global关键字的使用：
```python
x = 10  # 全局变量

def modify_global_variable():
    global x  # 声明x引用全局变量'x'
    x = 20   # 修改全局变量'x'

print("函数调用前：x =", x)
modify_global_variable()
print("函数调用后：x =", x)
```

输出：
```
函数调用前：x = 10
函数调用后：x = 20
```

在上面的例子中，如果没有使用global关键字，修改全局变量'x'的代码将被视为创建一个新的局部变量'x'，而不是修改全局变量。然而，使用global关键字后，函数知道'x'引用全局变量，并且可以正确地修改全局变量。
<a name="sK7NZ"></a>
## python全局变量和局部变量
在 Python 中，全局变量和局部变量是两种不同作用域下的变量：

1.  全局变量（Global Variables）： 
   - 定义：在函数外部或模块级别上定义的变量称为全局变量。全局变量可以在整个程序中访问，包括在函数内部。
   - 声明：**在函数内部要修改全局变量的值，需要使用 **`**global**`** 关键字进行声明，这样函数内部的变量赋值操作将指向全局变量，而不是创建一个新的局部变量**。
   - 作用域：全局变量的作用域是整个程序，从定义开始到程序结束，可以在程序的任意位置进行访问。
   - 示例：
```python
global_var = 10  # 全局变量

def example_function():
    print("全局变量 global_var =", global_var)  # 可以访问全局变量

example_function()
```

2.  局部变量（Local Variables）： 
   - 定义：在函数内部定义的变量称为局部变量。局部变量只能在其被定义的函数内部访问，其他函数或模块无法直接访问。
   - 作用域：**局部变量的作用域仅限于其所在的函数内部，在函数外部无法访问。**
   - 示例：
```python
def example_function():
    local_var = 20  # 局部变量
    print("局部变量 local_var =", local_var)

example_function()
#print(local_var)  # 这里会报错，因为无法在函数外部访问局部变量
```

需要注意的是，在函数内部可以访问全局变量，但如果要在函数内部修改全局变量的值，需要使用 `global` 关键字进行声明，否则将会创建一个新的局部变量，而不是修改全局变量。在编写程序时，应该根据变量的作用范围来合理使用全局变量和局部变量，以确保程序的正确运行和代码的可维护性。
<a name="jsjGD"></a>
## 局部变量外部能访问吗
不能。
<a name="MqZMJ"></a>
## 静态变量初始化(类变量、示例变量的区别)
在 Python 中，没有显式的静态变量的概念，因为 Python 不支持静态变量（类似于 C++ 或 Java 中的静态成员变量）。Python 中的**类变量**和**实例变量**可以**在类定义中初始化**，**但它们不是静态的**，而是在类的实例化过程中创建的。<br />在 Python 中，类变量是在类内部定义的变量，**它属于类而不是类的任何特定实例**。类变量在所有实例之间共享，**每个类的实例都可以访问和修改它**。你可以在类定义中直接初始化类变量，也可以在类的方法中通过类名来访问和修改类变量。<br />示例：
```python
class MyClass:
    class_variable = 10  # 类变量，初始化为10

    def __init__(self, instance_variable):
        self.instance_variable = instance_variable  # 实例变量

    def display(self):
        print("类变量 class_variable =", MyClass.class_variable)
        print("实例变量 instance_variable =", self.instance_variable)

# 创建两个类实例
obj1 = MyClass(20)
obj2 = MyClass(30)

# 访问类变量和实例变量
obj1.display()
obj2.display()

# 修改类变量的值
MyClass.class_variable = 50

# 类变量的修改对所有实例都生效
obj1.display()
obj2.display()
```

输出：
```
类变量 class_variable = 10
实例变量 instance_variable = 20
类变量 class_variable = 10
实例变量 instance_variable = 30
类变量 class_variable = 50
实例变量 instance_variable = 20
类变量 class_variable = 50
实例变量 instance_variable = 30
```

在上面的示例中，`class_variable` 是一个类变量，通过 `MyClass.class_variable` 来访问。每个类实例都可以访问它，并且对类变量的修改会对所有实例生效。实例变量是在类的构造函数 `__init__` 中定义的，并且每个实例都有它自己的实例变量。<br />请注意，虽然 Python 中没有显式的静态变量，但你可以通过类变量和实例变量来实现类似的功能。如果需要在类级别上存储数据并在所有实例之间共享，类变量是一个很好的选择。如果需要每个实例都有独立的数据，那么实例变量是更合适的选项。
<a name="KfHD8"></a>
## python 静态方法 类方法 实例方法的应用场景
在 Python 中，静态方法、类方法和实例方法是类中定义的不同类型的方法，它们在不同的应用场景下有不同的用途：

1.  静态方法（Static Method）： 
   - 定义：**静态方法是一个和类关联的方法**，**它不需要访问类的实例和类的状态，也不会隐式传递类或实例作为第一个参数。**在方法定义上，使用 `@staticmethod` 装饰器来声明一个静态方法。
   - 应用场景： 
      - **当方法不需要访问实例变量或类变量，仅仅是根据输入参数执行一些逻辑时，可以使用静态方法。**
      - 当一个方法既与类相关，又与实例无关时，适合定义为静态方法。
   - 示例：
```python
class MyClass:
    class_variable = 10  # 类变量

    def __init__(self, instance_variable):
        self.instance_variable = instance_variable  # 实例变量

    @staticmethod
    def static_method_example(x, y):
        return x + y

result = MyClass.static_method_example(5, 3)
print(result)  # 输出 8
```

2.  类方法（Class Method）： 
   - 定义：类方法是和类关联的方法，但在调用时第一个参数不是类的实例，而是类本身。在方法定义上，使用 `@classmethod` 装饰器来声明一个类方法。
   - 应用场景： 
      - **当方法需要访问或修改类级别的属性或方法时，可以使用类方法。**
      - 当需要在创建类的实例之前执行一些逻辑时，类方法非常有用。
   - 示例：
```python
class MyClass:
    class_variable = 10  # 类变量

    def __init__(self, instance_variable):
        self.instance_variable = instance_variable  # 实例变量

    @classmethod
    def class_method_example(cls, x):
        return cls.class_variable + x

result = MyClass.class_method_example(5)
print(result)  # 输出 15
```

3.  实例方法（Instance Method）： 
   - 定义：实例方法是最常见的方法类型，它需要传入类的实例作为第一个参数（通常命名为 `self`），并**可以访问和修改实例变量和类变量**。实例方法是类的默认方法类型，因此在定义时不需要使用任何装饰器。
   - 应用场景： 
      - **当方法需要访问或修改实例的属性或方法时，应该定义为实例方法。**
      - 当方法需要访问或修改类的属性或方法时，也可以使用实例方法，但需要通过类的实例来调用。
   - 示例：
```python
class MyClass:
    class_variable = 10  # 类变量

    def __init__(self, instance_variable):
        self.instance_variable = instance_variable  # 实例变量

    def instance_method_example(self, y):
        return self.instance_variable + y

obj = MyClass(5)
result = obj.instance_method_example(3)
print(result)  # 输出 8
```

综合来看，静态方法、类方法和实例方法各自有不同的应用场景，正确地使用它们可以使代码更具有可读性、可维护性和灵活性。根据方法需要访问的数据和功能，选择合适的方法类型能够更好地组织代码并提高代码的复用性。

<a name="lg2zI"></a>
## python __new__和__init__区别
**答：**

- `__new__` 方法控制对象的创建过程，**它在对象实例化前调用并返回实例对象**。
- `__init__` 方法**在对象实例化后调用**，**用于初始化对象的属性**。

在 Python 中，`__new__` 和 `__init__` 是两个特殊的方法，它们在类的实例化过程中扮演不同的角色。

1.  `__new__` 方法： 
   - `__new__` 是一个静态方法（类方法），它在一个对象实例化之前调用，并且必须返回一个实例对象。
   - `__new__` 方法负责创建实例对象，并将创建的实例对象返回给 `__init__` 方法作为参数。
   - `__new__` 方法是用来控制对象的创建过程，可以通过重写这个方法来实现自定义的对象创建逻辑，例如单例模式。
   - `**__new__**`** 方法的第一个参数是类本身（通常命名为 **`**cls**`**），之后的参数与 **`**__init__**`** 方法相同。**
   - **一般情况下，不需要直接重写 **`**__new__**`** 方法，除非有特殊的需求。**
2.  `__init__` 方法： 
   - `__init__` 是一个实例方法（普通方法），它在对象实例化后调用，并且用于初始化实例对象的属性。
   - `__init__` 方法接收 `__new__` 方法返回的实例对象作为第一个参数（通常命名为 `self`），并对其进行属性的初始化。
   - `__init__` 方法在对象创建后调用，它通常用于在对象创建后进行一些初始化操作。
   - `__init__` 方法不需要显式地返回任何值，它只负责初始化对象的属性。

示例：
```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        print("__new__ method called")
        instance = super(MyClass, cls).__new__(cls)
        return instance

    def __init__(self, x, y):
        print("__init__ method called")
        self.x = x
        self.y = y

# 创建对象实例
obj = MyClass(10, 20)
```

输出：
```
__new__ method called
__init__ method called
```

在上面的示例中，当创建 `MyClass` 类的实例对象时，首先会调用 `__new__` 方法，该方法负责创建实例对象并返回。然后，`__init__` 方法在对象实例化后调用，负责初始化对象的属性。

<a name="GJ3G7"></a>
## super和__init__()的区别
`super()` 和 `__init__()` 是 Python 中用于处理继承和初始化的两个不同的概念。

1.  `super()`： 
   - `super()` 是一个内置函数，用于调用父类（超类）的方法。通过 `super()` **可以在子类中调用父类的方法，实现方法的继承和重写。**
   - 在子类的方法中，使用 `super()` 可以调用父类的同名方法，避免重复编写相同的代码，并且在子类方法中增加额外的逻辑。这样可以保持代码的复用性和可维护性。
   - 通常情况下，`super()` 需要配合 `__init__()` 方法使用，以确保在子类中初始化父类的属性。
   - `super()` 的使用格式为：`super(子类, self)`，其中子类是当前类，self 是当前实例对象。
2.  `__init__()`： 
   - `__init__()` 是一个特殊的方法，用于初始化对象的属性。它是在对象实例化时自动调用的。
   - 在类的实例化过程中，`__init__()` 方法用于对对象的属性进行初始化。当创建对象时，可以在 `__init__()` 方法中设置对象的初始状态。
   - `__init__()` 方法可以在子类中重写，但通常情况下，需要通过 `super()` 调用父类的 `__init__()` 方法来确保子类对象正确地初始化父类的属性。
   - 在子类的 `__init__()` 方法中，可以通过 `super().__init__(参数)` 来调用父类的 `__init__()` 方法并传递相应的参数。

示例：

```python
class Parent:
    def __init__(self, name):
        self.name = name

    def greet(self):
        print(f"Hello, I am {self.name}")

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)
        self.age = age

    def greet(self):
        super().greet()
        print(f"I am {self.age} years old.")

# 创建子类对象
child = Child("Alice", 5)
child.greet()
```

输出：

```
Hello, I am Alice
I am 5 years old.
```

在上面的示例中，`Child` 类继承自 `Parent` 类。通过使用 `super()`，在子类的 `__init__()` 方法中调用父类的 `__init__()` 方法，确保在子类初始化时同时初始化父类的属性。
<a name="J0odv"></a>
## xrange和range区别
**答：**range()和xrange()都是在循环中使用，输出结果一样。

1. range()返回的是一个list对象，而xrange返回的是一个生成器对象(xrange object)。
2. xrange()则不会直接生成一个list，而是每次调用返回其中的一个值，**内存空间使用极少**。因而性能非常好，所以尽量用xrange吧。

**在python3 中没有xrange，只有range。range和python2 中的xrange()一样。**

<a name="LUee6"></a>
## return和yield区别

- return 用于普通函数中，用于返回一个值并终止函数的执行。
- yield 用于生成器函数中，**用于生成一个值，并保存函数的状态，**使得函数在每次调用时可以从上次 yield 处继续执行。**生成器函数返回一个生成器对象，只有在遍历生成器对象或使用 next() 函数获取值时，生成器函数才会执行。**
<a name="G3q63"></a>
##  __call__方法
**答：**当一个类定义了 __call__ 方法时，实例化的对象可以被视为可调用对象，就像函数一样被调用。<br />用途：<br />可以用于对象的初始化，以便在对象创建时执行一些逻辑。<br />可以用于对象的状态管理，将对象的状态保存在实例变量中，并在调用时根据不同的状态执行不同的操作。<br />可以用于实现特定的调用行为，使对象更加灵活和可定制。
<a name="Z90ts"></a>
## __str__方法
**答：**定义了 __str__ 方法时，它会覆盖默认的字符串表示形式，使得在使用 **print() **函数或 **str() **函数打印对象时，会输出我们定义的字符串表示形式而不是默认的对象地址。<br />用途：<br />定义对象的可读性好的字符串表示形式，方便调试和输出。<br />使对象更具有可读性和易于理解，而不是简单地输出对象的内存地址。<br />可以自定义显示对象的信息，包括对象的属性值、状态等
<a name="XUfsE"></a>
## 面向对象的特性，什么是面向对象，你如何理解
面向对象（Object-Oriented）是一种编程范式或编程风格，它是一种将现实世界中的事物抽象成对象，并通过对象之间的交互来描述问题和解决问题的方法。<br />面向对象编程的核心思想是将数据（属性）和行为（方法）组合在一个对象中，使得对象可以封装数据和行为，并且可以与其他对象进行交互。这种封装性和交互性使得面向对象编程具有很多优势，例如代码重用性、可维护性、扩展性、灵活性等。<br />面向对象编程的主要特性包括：

1.  封装（Encapsulation）：将数据和操作数据的方法封装在一个对象中，对外部隐藏对象的内部实现细节，只提供接口供其他对象使用。 
2.  继承（Inheritance）：通过继承可以创建一个新的类（子类）并从现有的类（父类）继承属性和方法。子类可以复用父类的代码，并可以在其中添加新的功能或覆盖父类的方法。 
3.  多态（Polymorphism）：多态允许使用相同的接口来处理不同的数据类型或对象类型。一个对象可以根据其具体类型来调用相应的方法，使得代码更加灵活和可扩展。 

面向对象编程是现代编程中广泛应用的编程范式，许多编程语言都支持面向对象的特性，如 Python、Java、C++、C#等。通过面向对象编程，可以更好地模拟现实世界的问题，将复杂的问题拆解成简单的对象，并通过对象之间的交互解决问题，从而使代码更具有结构性、可读性和可维护性。

<a name="jBTjC"></a>
## self有什么用
用于**在类的方法中引用对象实例本身**。在类的方法定义中，**第一个参数通常命名为 self，它表示当前方法所属的实例对象。**

<a name="yIDeF"></a>
## Python中类型public、private
并没有严格意义上的公共（public）和私有（private）类型的类成员。Python 中的属性和方法都是默认公共的，即可以在类的外部访问和调用。

<a name="rqHFP"></a>
## 面向对象程序的内存分配方式
答：python中大部分对象的内存分配发生在**堆**上。Python 使用自动垃圾回收机制来管理对象的内存，它使用引用计数和循环垃圾回收来追踪对象的引用情况，并在对象不再被引用时自动回收内存。<br />总结：

- 栈上分配适用于简单的数据类型和较小的对象，内存分配和回收是自动的。
- 堆上分配适用于复杂的数据结构和大型对象，内存分配和回收需要手动控制，使用自动垃圾回收机制进行管理。

面向对象程序的内存分配方式主要涉及对象的创建、存储和销毁。在大多数面向对象编程语言中，包括 Python，**对象的内存分配和管理主要分为两种方式**：**栈上分配**和**堆上分配**。

1.  栈上分配： 
   - 栈是一种线性数据结构，遵循后进先出（LIFO）的原则。在栈上分配内存时，内存空间是连续的，对象按照创建的顺序依次被分配到栈中。
   - 栈上分配的内存会在对象超出作用域时自动释放，即当对象不再被引用或离开了其所在的代码块时，内存会被自动回收。这种自动内存管理称为自动变量的生命周期管理。
   - 栈上分配适用于简单的数据类型和较小的对象，因为栈的内存空间有限，而且内存的分配和回收是非常高效的。
2.  堆上分配： 
   - 堆是一种动态数据结构，对象在堆上分配内存时，内存空间不是连续的，对象的大小可以在运行时确定。
   - 堆上分配的对象生命周期由程序员手动控制，需要显式地分配内存空间，并在使用完毕后显式地释放内存。如果不释放堆上分配的对象，就会出现内存泄漏。
   - 堆上分配适用于复杂的数据结构和大型对象，因为堆的内存空间较大，可以分配较大的对象，并且对象的生命周期可以长时间存在。

在 Python 中，**大部分对象的内存分配都发生在堆上**。Python 使用自动垃圾回收机制来管理对象的内存，它使用引用计数和循环垃圾回收来追踪对象的引用情况，并在对象不再被引用时自动回收内存。
<a name="c11Wj"></a>
## python类继承初始参数设置
super(子类,self)__init__()
<a name="VxQx3"></a>
## python多继承
在 Python 中，多继承是一种面向对象编程的特性，允许一个子类继承自多个父类。这意味着一个子类可以从多个父类中继承属性和方法。

Python 中使用逗号分隔多个父类来实现多继承，子类在定义时可以继承多个父类的特性。当子类调用方法时，Python 会按照特定的搜索顺序（MRO，Method Resolution Order）来查找方法，以保证方法的正确调用。

下面是一个简单的示例来说明多继承的用法：

```python
class Animal:
    def speak(self):
        print("Animal speaks")

class Mammal:
    def run(self):
        print("Mammal runs")

class Bird:
    def fly(self):
        print("Bird flies")

# 多继承，一个子类继承自多个父类
class Bat(Animal, Mammal, Bird):
    pass

# 创建子类对象
bat = Bat()

# 调用继承自不同父类的方法
bat.speak()  # 输出 "Animal speaks"
bat.run()    # 输出 "Mammal runs"
bat.fly()    # 输出 "Bird flies"
```

在上面的示例中，我们定义了三个父类 `Animal`、`Mammal` 和 `Bird`，它们分别有不同的方法。然后我们定义了一个子类 `Bat`，它继承自这三个父类。通过多继承，子类 `Bat` 继承了来自不同父类的方法。当我们创建 `Bat` 类的对象 `bat` 后，可以调用继承自不同父类的方法。

需要注意的是，多继承可能会导致方法的冲突，即多个父类中可能有相同名称的方法。在这种情况下，Python 会按照特定的 MRO 顺序来解决冲突，并调用第一个匹配的方法。MRO 是通过 C3 线性化算法来计算的，默认情况下，Python 会根据类的继承顺序来计算 MRO。如果有需要，也可以通过使用 `super()` 来指定调用特定父类的方法。

虽然多继承在某些情况下可以方便地组合不同的功能，但需要谨慎使用，避免出现复杂的继承关系和方法冲突。

<a name="fueK9"></a>
## Python有重写吗，python有重载吗？
在 Python 中，支持方法重写（Method Overriding），但是不支持方法重载（Method Overloading）。

1.  方法重写（Method Overriding）：<br />方法重写是指在子类中定义一个与父类中同名的方法，从而覆盖父类中的方法。当子类对象调用这个方法时，子类的方法会优先执行，而不是父类的方法。<br />方法重写通常用于子类需要对父类的方法进行定制化实现的场景，从而实现多态性。Python 中通过在子类中定义与父类同名的方法来实现方法重写。 
2.  方法重载（Method Overloading）：<br />方法重载是指在一个类中定义多个同名方法，但这些方法的参数类型或参数个数不同，从而实现根据传入参数的不同调用不同的方法。方法重载允许在同一个类中有多个方法名相同但参数不同的方法。<br />然而，**Python 不支持方法重载**。在 Python 中，方法的名称是唯一的，即同一个类中不能有多个同名方法，无论这些方法的参数是否不同。在 Python 中，方法重载可以通过使用默认参数值或可变参数来实现类似的效果。 

示例说明：

```python
class Parent:
    def my_method(self):
        print("This is the parent's method.")

class Child(Parent):
    def my_method(self):  # 方法重写，子类覆盖了父类的方法
        print("This is the child's method.")

# 创建子类对象
child = Child()

# 调用子类的方法，会执行子类中重写的方法
child.my_method()  # 输出 "This is the child's method."
```

在上面的示例中，我们定义了一个父类 `Parent` 和一个子类 `Child`，子类中重写了父类的方法 `my_method`。当我们调用子类对象的 `my_method()` 方法时，执行的是子类中重写的方法。

虽然 Python 不支持方法重载，但是你可以使用默认参数值或可变参数来实现类似的效果，从而达到不同参数调用不同方法的目的。
<a name="IpxOk"></a>
## python实现多态的3个条件，代码实现
在 Python 中，多态性是面向对象编程的一个重要概念，它可以使不同的类对象以相同的方式对待，从而实现更灵活的代码结构和扩展性。**Python 实现多态的三个条件**如下：

1. **继承**：多态需要基于继承关系，子类继承了父类的属性和方法。
2. **方法重写**：子类可以重写（覆盖）父类的方法，从而在子类中定义自己特定的实现逻辑。
3. **统一的接口**：多态要求不同的子类对象能够使用相同的接口或方法名，以实现同样的功能。

下面是一个简单的代码示例来演示 Python 中的多态性：

```python
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Woof! Woof!"

class Cat(Animal):
    def sound(self):
        return "Meow! Meow!"

# 多态性示例
def make_sound(animal):
    print(animal.sound())

# 创建不同的子类对象
dog = Dog()
cat = Cat()

# 调用同一个函数，但是实际输出结果根据传入的子类对象而不同
make_sound(dog)  # 输出 "Woof! Woof!"
make_sound(cat)  # 输出 "Meow! Meow!"
```

在上面的示例中，我们定义了一个基类 `Animal`，其中有一个抽象方法 `sound()`。然后我们定义了两个子类 `Dog` 和 `Cat`，它们分别重写了 `sound()` 方法，分别返回不同的声音。接下来，我们定义了一个函数 `make_sound()`，它接受一个 `Animal` 类型的参数，并调用参数对象的 `sound()` 方法。当我们分别传入 `Dog` 和 `Cat` 类的对象时，函数 `make_sound()` 在不同的情况下会产生不同的输出，实现了多态性。

通过这种方式，我们可以在代码中使用统一的接口来处理不同的对象，而不需要关心对象的具体类型，从而使代码更加灵活和可扩展。
<a name="hbcBl"></a>
## python有动态多态吗？
有，通过创建父类对象和子类对象，然后把子类对象赋值给原父类对象，是假的，会被垃圾回收的。

<a name="rlebD"></a>
## python有静态多态吗？
没有。静态多态是基于函数重载或运算符重载的。python不支持重载。

<a name="dYuGp"></a>
## 邮箱的正则表达式
邮箱的正则表达式是一种用于匹配邮箱地址的模式。邮箱地址通常由本地部分（用户名）和域名部分组成，以 "@" 符号分隔。根据邮箱地址的格式规则，可以使用正则表达式来验证和提取有效的邮箱地址。

以下是一个简单的邮箱地址正则表达式的示例：

```
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

解释：

- `^`：表示匹配字符串的开头。
- `[a-zA-Z0-9._%+-]+`：表示匹配至少一个或多个字母、数字、点、下划线、百分号、加号、减号。
- `@`：表示匹配 @ 符号。
- `[a-zA-Z0-9.-]+`：表示匹配至少一个或多个字母、数字、点、减号。
- `\.`：表示匹配点符号（因为点在正则表达式中有特殊含义，需要使用反斜杠进行转义）。
- `[a-zA-Z]{2,}`：表示匹配至少两个或多个字母，用于匹配域名部分。
- `$`：表示匹配字符串的结尾。

这个正则表达式可以匹配大部分常见的邮箱地址格式，但请注意，邮箱地址的规则是比较复杂的，实际应用中可能需要根据具体需求进行调整和扩展。

在 Python 中，可以使用 `re` 模块来进行正则表达式的匹配，示例代码如下：

```python
import re

def is_valid_email(email):
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    return re.match(pattern, email) is not None

# 示例使用
email1 = "user@example.com"
email2 = "user123@subdomain.example.co.uk"
email3 = "invalid_email"

print(is_valid_email(email1))  # 输出 True
print(is_valid_email(email2))  # 输出 True
print(is_valid_email(email3))  # 输出 False
```

请注意，虽然正则表达式可以用于简单的邮箱地址验证，但在实际应用中，出于安全性和稳定性考虑，更好的方法是使用现有的验证库或框架来处理邮箱地址的验证。

<a name="zV3qF"></a>
## python支持多线程吗？
是的，Python 支持多线程。Python 提供了多线程编程的标准库 `threading`，它允许开发者在一个程序中同时运行多个线程，实现并发执行。**多线程可以让程序同时执行多个任务，从而提高程序的执行效率和资源利用率。**<br />虽然 Python** 支持多线程编程**，但是需要注意的是，**Python 的多线程由于全局解释器锁（Global Interpreter Lock，GIL）的存在，导致在同一时刻只能有一个线程执行 Python 字节码，因此在 CPU 密集型任务中，多线程并不能充分利用多核处理器的优势。**<br />然而，**对于 I/O 密集型任务，例如网络请求、文件读写等，Python 多线程仍然是有用的，因为在 I/O 操作时，线程可以释放 GIL，允许其他线程执行 Python 字节码，从而提高程序的响应性能。**<br />如果需要利用多核处理器的优势来实现并行计算，**可以考虑使用 Python 的多进程编程，通过 **`**multiprocessing**`** 模块来实现。**多进程模型避免了 GIL 的限制，每个进程有独立的 Python 解释器和 GIL。

总结：

- Python 支持多线程编程，但由于 GIL 的存在，多线程主要适用于 I/O 密集型任务。
- 对于 CPU 密集型任务，可以考虑使用多进程编程来实现并行计算。
<a name="Y1Xuq"></a>
### 什么IO密集型情形适合多线程？举个例子。
例如**网络请求**、**文件读写**、数据库访问等。在这些任务中，**线程在进行输入/输出操作时通常会处于阻塞状态，**等待数据的到达或数据的读取，**此时可以释放 GIL，让其他线程执行 Python 字节码**，从而提高程序的并发性和响应性能。

<a name="CJb2o"></a>
## Python多线程实现方式
在 Python 中，可以使用 `threading` 模块来实现多线程。`threading` 模块提供了对线程的支持，可以创建、管理和控制多个线程，实现并发执行。<br />下面是使用 `threading` 模块实现多线程的简单示例：
```python
import threading
import time

# 定义一个线程的执行函数
def print_numbers():
    for i in range(1, 6):
        print(f"Number: {i}")
        time.sleep(1)  # 模拟耗时操作

# 创建多个线程并启动
threads = []
for _ in range(3):
    thread = threading.Thread(target=print_numbers)
    thread.start()
    threads.append(thread)

# 等待所有线程完成
for thread in threads:
    thread.join()

print("All threads are finished.")
```

在上面的示例中，我们定义了一个 `print_numbers()` 函数，它打印数字 1 到 5，并模拟每次打印之间的耗时操作。然后，我们创建了 3 个线程，并启动这些线程，每个线程都会执行 `print_numbers()` 函数。这样，三个线程就可以同时执行打印操作，实现了并发执行。

需要注意的是，Python 中的多线程由于全局解释器锁（Global Interpreter Lock，GIL）的存在，多个线程不能同时执行 CPU 密集型任务，**因为在同一时刻只有一个线程能够执行 Python 字节码。**因此，在 CPU 密集型任务中，多线程并不能充分利用多核处理器的优势。<br />对于 I/O 密集型任务，例如网络请求、文件读写等，多线程仍然是有用的，因为在 I/O 操作时，线程可以释放 GIL，允许其他线程执行 Python 字节码，从而提高程序的响应性能。如果需要利用多核处理器的优势来实现并行计算，可以考虑使用 Python 的多进程编程，通过 `multiprocessing` 模块来实现。
<a name="crpUD"></a>
## python多线程的优缺点
优点：

1. 并发执行：多线程可以使程序同时执行多个任务，从而提高程序的并发性，特别适用于 I/O 密集型任务，如网络请求、文件读写等。
2. 共享数据：多线程可以共享数据，简化线程之间的通信和数据传递，使得代码编写更加简洁。
3. 轻量级：线程是相对轻量级的，创建和销毁线程的开销相对较小，适合在程序中创建大量的线程。

缺点：

1. 全局解释器锁（GIL）：Python 的多线程由于 GIL 的存在，导致在同一时刻只能有一个线程执行 Python 字节码。这意味着多线程不能充分利用多核处理器的优势，特别对于 CPU 密集型任务，多线程的性能有限。
2. 线程安全问题：多线程访问共享数据时，如果没有正确地进行同步控制，可能会导致竞态条件（Race Condition）和数据不一致等线程安全问题。
3. 调试困难：多线程程序中出现问题时，由于线程的不确定性，调试和定位问题可能更加困难。

总结：<br />在 Python 中，多线程适用于 I/O 密集型任务和需要并发执行的场景。对于 CPU 密集型任务，由于 GIL 的限制，多线程性能有限，可以考虑使用多进程编程来充分利用多核处理器的优势。同时，在多线程编程时需要注意线程安全问题，避免出现竞态条件和数据不一致等问题。
<a name="kDsLM"></a>
## 栈内存是在多线程的共享空间吗?
在多线程中，**每个线程都有自己的栈内存，栈内存是线程私有的，不是多线程的共享空间。**<br />栈内存是用于存储函数调用和局部变量的一块内存区域。每个线程都有自己的执行栈，用于保存函数调用的上下文信息，包括函数的参数、局部变量以及函数调用的返回地址。当一个函数被调用时，它的局部变量会被分配到该线程的栈内存中，在函数返回后，这些局部变量所占用的栈内存会被自动释放。<br />由于栈内存是线程私有的，因此多个线程之间的栈内存是相互独立的，它们不会共享栈内存空间。这意味着每个线程在执行函数调用和使用局部变量时，都是在自己的栈内存中进行操作，不会相互影响。<br />虽然栈内存是线程私有的，但是线程共享进程的其他资源，例如堆内存、文件句柄、全局变量等。这也是为什么在多线程编程中需要注意线程安全问题，特别是对于共享资源的访问，需要使用同步机制来保证多个线程之间的正确执行和数据一致性。
<a name="v1Ebd"></a>
## GIL，GIL 的目的是？
GIL（Global Interpreter Lock）是 Python 解释器中的**全局解释器锁**，它是一种机制**用于保证在多线程环境下只有一个线程可以执行 Python 字节码。**<br />Python 中的 GIL 是由于 CPython 解释器的设计所带来的特性。CPython 是 Python 最常用的解释器，它在执行 Python 代码时，会将多个线程的执行限制在同一时刻只有一个线程能够执行 Python 字节码。这意味着在 CPython 中，**多线程不能真正地并行执行，无法利用多核处理器的优势**。<br />GIL 的**目的是保护共享资源**，特别是 Python 对象。由于 Python 解释器中的**许多对象**（例如整数、浮点数、字符串等）**是共享的**，如果不进行保护，多个线程同时访问这些共享对象时可能会引发竞态条件（Race Condition）和数据不一致等**线程安全问题。**<br />**通过 GIL，Python 解释器可以保证在同一时刻只有一个线程执行 Python 字节码，避免了多线程访问共享资源时的竞争问题，从而简化了线程间的同步控制和数据传递**。但同时也带来了一些限制，特别是对于 CPU 密集型任务，多线程无法充分利用多核处理器的优势，因为只有一个线程能够执行 Python 字节码。<br />虽然 GIL 限制了多线程在 CPU 密集型任务中的性能，但**对于 I/O 密集型任务，GIL 的影响较小，因为在 I/O 操作时线程可以释放 GIL**，允许其他线程执行 Python 字节码，从而提高程序的并发性和响应性能。对于 CPU 密集型任务，可以考虑使用 Python 的多进程编程，通过 `multiprocessing` 模块来实现并行计算，从而充分利用多核处理器的优势。
<a name="LesKv"></a>
## 进程(或线程)怎么切换？
在操作系统中，进程（或线程）切换是通过上下文切换（Context Switching）来实现的。**上下文切换是指将当前运行进程（或线程）的状态（如寄存器的值、程序计数器、栈指针等）保存到内存中，并加载下一个要运行的进程（或线程）的状态，使得新的进程（或线程）可以继续执行。**<br />进程切换和线程切换的过程类似，只是线程切换涉及到的上下文切换开销较小，因为线程之间共享进程的地址空间和其他资源，而进程之间是独立的。<br />下面简要描述进程（或线程）切换的过程：

1.  保存当前进程（或线程）的上下文：当操作系统决定要切换到另一个进程（或线程）时，首先会将当前进程（或线程）的寄存器的值、程序计数器、栈指针等状态信息保存到该进程（或线程）的控制块（也称为进程控制块或线程控制块）中。 
2.  选择新的进程（或线程）：操作系统根据调度算法从就绪队列中选择下一个要运行的进程（或线程）。 
3.  恢复新进程（或线程）的上下文：将被选中的新进程（或线程）的状态信息从其控制块中加载到寄存器、程序计数器、栈指针等硬件寄存器中，准备开始执行。 
4.  执行新的进程（或线程）：CPU 开始执行新进程（或线程）的指令，恢复其在上一次切换时的执行状态。 

上下文切换是一种高开销的操作，因为涉及到将寄存器的值和其他状态信息保存到内存中，并从内存中加载新的状态信息到寄存器。因此，过多的进程（或线程）切换会导致系统性能下降。在多线程编程中，尽量减少不必要的线程切换是提高程序性能的重要优化手段。
<a name="go2DR"></a>
## 怎么降低多线程切换的开销?
降低多线程切换的开销可以采取以下一些方法：

1.  **使用多进程**：多进程模型避免了全局解释器锁（GIL）的限制，每个进程有独立的 Python 解释器和 GIL，因此在多进程模型中，每个进程可以同时执行 Python 字节码，充分利用多核处理器的优势。对于 CPU 密集型任务，可以考虑使用多进程编程。 
2.  **减少线程数量**：过多的线程会增加上下文切换的开销，因此在设计多线程程序时，需要根据实际情况合理选择线程数量，避免创建过多的线程。 
3.  **使用线程池**：线程池是一种线程管理的技术，它在程序启动时预先创建一组线程，这些线程可以被多个任务共享执行。使用线程池可以避免频繁地创建和销毁线程，减少上下文切换的开销。 
4.  优化算法：在多线程程序中，尽量减少对共享资源的竞争，可以采用一些优化算法和数据结构来降低线程之间的竞争，从而减少上下文切换的开销。 
5.  **使用异步编程**：异步编程模型通过事件循环机制实现非阻塞的并发执行，可以避免线程的上下文切换，提高程序的并发性能。Python 中的 asyncio 模块提供了异步编程的支持。 
6.  使用原生扩展模块：对于 CPU 密集型任务，可以考虑使用原生扩展模块（如 Cython 或 C/C++ 编写的扩展模块）来替代 Python 的代码，从而避免 GIL 的限制，提高程序的执行效率。 

需要根据具体的应用场景和任务特点来选择合适的优化方法。总体来说，在多线程编程中，合理设计和优化多线程的数量和调度机制，避免线程之间频繁切换，可以提高程序的性能。

<a name="QCB7d"></a>
## python中的线程有几种方法？
在 Python 中，实现多线程有三种主要的方法：

1. 使用 `threading` 模块：`threading` 模块是 Python 的标准库，提供了对线程的支持。通过创建 `Thread` 类的实例，可以在 Python 中创建和管理多线程。这是最常用的实现多线程的方法。

示例：

```python
import threading

def print_numbers():
    for i in range(1, 6):
        print(f"Number: {i}")

# 创建线程并启动
thread = threading.Thread(target=print_numbers)
thread.start()
```

2. 继承 `threading.Thread` 类：除了使用 `threading` 模块外，还可以通过继承 `threading.Thread` 类来实现多线程。在这种方法中，可以创建一个自定义的线程类，并重写 `run()` 方法来定义线程的执行逻辑。

示例：

```python
import threading

class MyThread(threading.Thread):
    def run(self):
        for i in range(1, 6):
            print(f"Number: {i}")

# 创建线程并启动
thread = MyThread()
thread.start()
```

3. 使用 `concurrent.futures` 模块：`concurrent.futures` 模块是 Python 3.2 以后引入的，并提供了高级的并发执行功能。`concurrent.futures` 提供了 `ThreadPoolExecutor` 和 `ProcessPoolExecutor` 两个类，分别用于线程池和进程池的实现。使用 `ThreadPoolExecutor` 可以更方便地实现多线程编程。

示例：

```python
from concurrent.futures import ThreadPoolExecutor

def print_numbers():
    for i in range(1, 6):
        print(f"Number: {i}")

# 创建线程池并提交任务
with ThreadPoolExecutor() as executor:
    future = executor.submit(print_numbers)
```

这三种方法都可以用来实现多线程编程，选择哪种方法取决于具体的需求和设计。最常用的是第一种方法，通过 `threading` 模块来创建和管理线程。
<a name="jIbp3"></a>
## python线程池
在 Python 中，线程池是一种并发编程模型，它通过预先创建一组线程来执行多个任务，从而避免频繁地创建和销毁线程，提高程序的执行效率。Python 提供了 `concurrent.futures` 模块来实现线程池和进程池。<br />在 `concurrent.futures` 模块中，线程池的实现是通过 `ThreadPoolExecutor` 类来实现的。`ThreadPoolExecutor` 提供了一个简单的接口，可以方便地提交任务到线程池中执行，并返回任务的执行结果。

下面是使用线程池的简单示例：
```python
from concurrent.futures import ThreadPoolExecutor
import time

# 定义一个任务函数
def task(name):
    print(f"Task {name} started")
    time.sleep(2)  # 模拟耗时操作
    print(f"Task {name} finished")
    return f"Result from Task {name}"

# 创建线程池
with ThreadPoolExecutor(max_workers=3) as executor:
    # 提交任务到线程池中执行
    future1 = executor.submit(task, "A")
    future2 = executor.submit(task, "B")
    future3 = executor.submit(task, "C")

    # 获取任务的执行结果
    result1 = future1.result()
    result2 = future2.result()
    result3 = future3.result()

    print("All tasks are finished")
    print("Results:", result1, result2, result3)
```

在上面的示例中，我们使用了 `ThreadPoolExecutor` 创建了一个线程池，最大线程数设置为 3。然后，我们通过 `executor.submit()` 方法提交了三个任务到线程池中执行。每个任务都是一个耗时的操作，模拟了 2 秒的执行时间。通过 `future.result()` 方法可以获取任务的执行结果。最后，我们打印了所有任务执行完成的信息和任务的执行结果。

通过使用线程池，我们可以避免了频繁地创建和销毁线程的开销，提高了程序的执行效率。线程池还可以设置最大线程数，避免过多的线程导致系统资源耗尽。总体上，线程池是一种方便和高效的并发编程模型，在 Python 中非常实用。
<a name="JpIlM"></a>
## python多线程线程锁
**答：**threading模块中的Lock类可以创建线程锁。lock.acquire()方法可以获取锁，lock.release()方法释放锁。<br />解释：<br />在 Python 中，线程锁（Thread Lock）是一种同步机制，用于在多线程环境中保护共享资源，避免多个线程同时对共享资源进行写操作，从而防止出现竞态条件（Race Condition）和数据不一致的问题。<br />Python 提供了 `threading` 模块中的 `Lock` 类来实现线程锁。`Lock` 类提供了两个主要方法：`acquire()` 和 `release()`。当一个线程调用 `acquire()` 方法时，它会尝试获取锁，如果锁当前没有被其他线程占用，则获取成功，该线程可以继续执行；如果锁被其他线程占用，则该线程会被阻塞，直到锁被释放。当一个线程完成对共享资源的访问后，可以调用 `release()` 方法来释放锁，让其他线程可以获取锁并访问共享资源。

下面是一个简单的使用线程锁的示例：
```python
import threading

# 共享资源
counter = 0

# 创建线程锁
lock = threading.Lock()

# 线程函数
def increment():
    global counter
    for _ in range(100000):
        # 获取线程锁
        lock.acquire()
        counter += 1
        # 释放线程锁
        lock.release()

# 创建多个线程并启动
threads = []
for _ in range(5):
    thread = threading.Thread(target=increment)
    thread.start()
    threads.append(thread)

# 等待所有线程执行完毕
for thread in threads:
    thread.join()

# 打印计数器的值
print("Counter value:", counter)
```

在上面的示例中，我们创建了一个名为 `counter` 的共享资源，然后使用 `threading.Lock()` 创建了一个线程锁 `lock`。在线程函数 `increment()` 中，我们使用 `lock.acquire()` 获取线程锁，并对 `counter` 执行 10 万次自增操作，然后通过 `lock.release()` 释放线程锁。这样，每次只有一个线程能够获取锁并执行自增操作，从而保护了共享资源的完整性。

需要注意的是，使用线程锁可能会带来一定的性能开销，因为每个线程在获取和释放锁时需要进行同步操作。因此，在设计多线程程序时，需要根据实际情况合理使用线程锁，避免过多的线程锁带来的性能下降。
<a name="P0hRN"></a>
## python 如何处理高并发?
在 Python 中处理高并发可以采取以下几种方法：

1.  使用**多线程或多进程**：利用 Python 的 `threading` 模块实现多线程或使用 `multiprocessing` 模块实现多进程，可以在高并发环境下同时处理多个请求。对于 I/O 密集型任务，使用多线程可以提高程序的并发性能；对于 CPU 密集型任务，使用多进程可以充分利用多核处理器的优势。 
2.  使用**异步编程**：Python 提供了 `asyncio` 模块来支持异步编程，通过事件循环机制实现非阻塞的并发执行。使用异步编程可以在一个线程中处理多个请求，避免了线程切换的开销，提高了程序的并发性能。 
3.  使用**线程池或进程池**：通过使用 `concurrent.futures` 模块的线程池或进程池，可以预先创建一组线程或进程，并在高并发时共享这些线程或进程来处理请求。这样可以避免频繁地创建和销毁线程或进程，提高程序的执行效率。 
4.  使用缓存：对于频繁访问的数据，可以使用缓存来存储已经计算过的结果，避免重复计算，提高程序的响应性能。 
5.  使用负载均衡：在面对高并发时，可以使用负载均衡技术将请求分发到多个服务器上，使得每个服务器的负载均衡，从而提高整个系统的处理能力。 


需要根据具体的应用场景和需求来选择合适的处理方法。综合运用以上技术和优化手段，可以有效地处理高并发情况，提高程序的性能和稳定性。

<a name="XBuEG"></a>
## 大概讲下multiprocess怎么使用？
`multiprocessing` 是 Python 的一个标准库，用于实现多进程编程。它提供了创建进程、进程间通信和进程池等功能，使得在 Python 中编写多进程的程序变得简单和方便。

下面简要介绍 `multiprocessing` 模块的使用方法：

1. 创建进程：<br />使用 `multiprocessing.Process` 类可以创建一个新的进程。你需要定义一个函数或可调用对象作为进程的执行体，并通过 `Process` 类的构造函数来创建进程实例。然后调用 `start()` 方法启动进程，`run()` 方法中的代码将在新进程中执行。

```python
import multiprocessing

def worker():
    print("Worker process")

if __name__ == "__main__":
    process = multiprocessing.Process(target=worker)
    process.start()
    process.join()
```

2. 进程间通信：<br />进程间通信可以通过 `multiprocessing` 模块的一些数据交换机制来实现，如 `Queue`、`Pipe`、`Value` 和 `Array` 等。它们可以用于多个进程之间传递数据或共享数据。

```python
import multiprocessing

def worker(queue):
    data = queue.get()
    print(f"Received data: {data}")

if __name__ == "__main__":
    queue = multiprocessing.Queue()
    process = multiprocessing.Process(target=worker, args=(queue,))
    process.start()

    # 向进程发送数据
    queue.put("Hello from main process")

    process.join()
```

3. 进程池：<br />`multiprocessing.Pool` 类可以用于创建进程池，通过它可以方便地执行一批任务并控制并发数。你可以调用 `apply()`、`map()`、`starmap()` 等方法来执行任务，进程池会自动管理进程的创建和回收。

```python
import multiprocessing

def worker(x):
    return x * x

if __name__ == "__main__":
    with multiprocessing.Pool(processes=4) as pool:
        results = pool.map(worker, [1, 2, 3, 4, 5])
        print(results)
```

以上是 `multiprocessing` 模块的简要使用方法。`multiprocessing` 提供了丰富的功能来实现多进程编程，可根据具体需求灵活使用。值得注意的是，在 Windows 系统下，由于其进程创建机制的限制，需要将进程创建的代码放在 `if __name__ == "__main__":` 条件下，以避免进程创建的问题。在 Unix-like 系统下没有这个限制。
<a name="E9Tfn"></a>
### multiprocess多进程 map的用法？
`multiprocessing.Pool` 类中的 `map()` 方法用于在进程池中执行一批任务，并返回每个任务的结果。`map()` 方法会阻塞主进程，直到所有任务都完成并返回结果。

`map()` 方法的使用方法如下：

```python
import multiprocessing

def worker(x):
    return x * x

if __name__ == "__main__":
    with multiprocessing.Pool(processes=4) as pool:
        results = pool.map(worker, [1, 2, 3, 4, 5])

    print(results)
```

在上面的示例中，我们使用 `multiprocessing.Pool` 创建了一个拥有 4 个进程的进程池。然后，我们调用 `pool.map(worker, [1, 2, 3, 4, 5])` 来执行任务。`worker` 函数将会在进程池的每个进程中执行，每个进程分别处理传入的参数（1, 2, 3, 4, 5），并返回计算结果。最后，`map()` 方法会返回一个列表，包含了每个任务的执行结果。

在进程池中，`map()` 方法会按照传入的可迭代对象（例如列表）中的顺序依次执行任务，并且会等待所有任务完成后才会返回结果。如果需要获取每个任务的结果，可以使用 `map()` 方法的返回值。如果任务执行过程中抛出异常，`map()` 方法会将异常传播到主进程，并在主进程中重新抛出。

使用进程池的 `map()` 方法能够充分利用多核处理器的优势，提高任务的并发执行能力。它适用于在多进程环境下执行一批独立的任务，并返回结果集。在处理多个任务时，使用进程池能够更高效地进行并发计算。
<a name="eRRud"></a>
## python线程、进程、协程
在 Python 中，线程、进程和协程都是实现并发编程的方式，用于处理多个任务的同时执行。它们在多任务处理方式和资源管理上有不同的特点和适用场景。

1.  线程（Thread）： 
   - 线程是进程的一部分，多个线程共享同一进程的资源（如内存空间、文件句柄等）。
   - 线程的创建和销毁开销较小，适用于 I/O 密集型任务，如网络请求、文件读写等。
   - 由于全局解释器锁（GIL）的存在，Python 的线程在 CPU 密集型任务中无法充分利用多核处理器的优势。
2.  进程（Process）： 
   - 进程是一个独立的执行单元，每个进程有自己独立的地址空间和资源。
   - 进程之间相互独立，互不影响，可以利用多核处理器的优势实现并行计算。
   - 进程的创建和销毁开销较大，适用于 CPU 密集型任务。
3.  协程（Coroutine）： 
   - 协程是一种轻量级的线程，可以在单个线程内实现并发执行。
   - 协程在程序中可以像函数一样进行调用，可以挂起和恢复执行，适用于高并发的 I/O 密集型任务。
   - 通过 `asyncio` 模块可以实现异步编程和协程。

综合来说，线程适合于 I/O 密集型任务，进程适合于 CPU 密集型任务，而协程适用于高并发的 I/O 密集型任务。可以根据任务的特点和需求来选择合适的并发编程方式。在 Python 中，通过 `threading` 模块实现线程、通过 `multiprocessing` 模块实现进程，通过 `asyncio` 模块实现异步编程和协程。
<a name="OqmgN"></a>
## python 的异常怎么使用
try except finally
<a name="NOPF0"></a>
## Python打开一个文件，找出某个字符串最快的方法
在 Python 中，找出某个字符串在文件中出现的最快方法通常是使用多线程或多进程并行处理。这样可以利用多核处理器的优势，同时搜索文件的不同部分，加快查找速度。

下面是一个使用多线程的示例：

```python
import threading

# 定义搜索函数
def search_string_in_file(file_path, search_string, result_list, start_line, end_line):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line_number, line in enumerate(lines[start_line:end_line], start=start_line):
            if search_string in line:
                result_list.append((line_number, line.strip()))

# 主函数
def main():
    file_path = 'path/to/your/file.txt'
    search_string = 'your_search_string'
    num_threads = 4

    result_list = []
    threads = []

    with open(file_path, 'r') as file:
        total_lines = sum(1 for line in file)

    chunk_size = total_lines // num_threads

    for i in range(num_threads):
        start_line = i * chunk_size
        end_line = start_line + chunk_size if i < num_threads - 1 else total_lines

        thread = threading.Thread(target=search_string_in_file, args=(file_path, search_string, result_list, start_line, end_line))
        threads.append(thread)

    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()

    # 打印结果
    for line_number, line in result_list:
        print(f"Line {line_number}: {line}")

if __name__ == "__main__":
    main()
```

在上面的示例中，我们使用了 4 个线程来并行搜索文件中的字符串。首先，我们获取文件的总行数，然后将文件划分为多个部分，每个线程负责搜索其中的一部分。通过多线程的并行搜索，可以加快查找字符串的速度。

注意：并行处理可能会带来一定的开销，特别是在小文件或查找字符串较简单的情况下，并行处理可能不一定能够获得明显的性能提升。在实际应用中，需要根据文件大小和查找字符串的复杂度来确定是否使用多线程或多进程的并行处理。

<a name="vV3wp"></a>
## 写一个awk 打印出第10行
在 Python 中，你可以使用以下代码来模拟实现类似 awk 打印第 10 行的功能：

```python
def print_10th_line(file_path):
    with open(file_path, 'r') as file:
        for line_number, line in enumerate(file, start=1):
            if line_number == 10:
                print(line.strip())
                break

if __name__ == "__main__":
    file_path = 'path/to/your/file.txt'
    print_10th_line(file_path)
```

在上述代码中，我们定义了一个名为 `print_10th_line` 的函数，该函数接收文件路径作为参数，并使用 `with open()` 来打开文件并进行逐行遍历。`enumerate(file, start=1)` 用于同时获取行号和行内容，从第 1 行开始计数。当行号为 10 时，即打印出第 10 行的内容。

请将 `'path/to/your/file.txt'` 替换为实际文件路径，并运行代码以打印第 10 行内容。


<a name="HtYtB"></a>
## shell输出变量内容
```bash
#!/bin/bash

# 定义一个变量
name="Alice"

# 输出变量内容
echo "Hello, ${name}!"
```

<a name="VniQH"></a>
## 千万级大规模数据读写(从数据库，缓存，主从集群，分库分表的角度去讨论)


<a name="dd2Gl"></a>
## Selenium中XPath选取元素的方式
在 Selenium 中，XPath 是一种强大的定位元素的方式。**XPath 是一种用于在 XML 和 HTML 文档中定位元素的语言，它可以通过元素的层级关系、属性和文本内容等信息来精确地定位元素**。<br />在 Selenium 中，可以使用 `find_element_by_xpath()` 方法来根据 XPath 表达式选取元素。该方法用于在当前页面中查找符合 XPath 表达式的第一个元素，如果要查找多个符合条件的元素，可以使用 `find_elements_by_xpath()` 方法。<br />以下是使用 XPath 选取元素的示例：
```python
from selenium import webdriver

# 创建 Chrome 浏览器实例
driver = webdriver.Chrome()

# 打开网页
driver.get('https://example.com')

# 使用 XPath 定位元素并进行操作
# 选取第一个 h1 元素，并打印其文本内容
element = driver.find_element_by_xpath('//h1')
print(element.text)

# 选取所有 p 元素，并打印其文本内容
elements = driver.find_elements_by_xpath('//p')
for element in elements:
    print(element.text)

# 关闭浏览器
driver.quit()
```

在上述示例中，我们首先导入 Selenium 的 `webdriver` 模块，并创建了一个 Chrome 浏览器实例。然后使用 `get()` 方法打开了一个网页。接着使用 `find_element_by_xpath()` 方法根据 XPath 表达式选取了第一个 `h1` 元素，并使用 `text` 属性获取了该元素的文本内容。接着使用 `find_elements_by_xpath()` 方法选取了所有 `p` 元素，并使用循环遍历输出了每个 `p` 元素的文本内容。

XPath 的表达式非常灵活，可以根据元素的不同特征来定位元素，例如元素的标签名、属性、父子关系等。通过合理使用 XPath，可以方便而准确地选取页面中的元素。
<a name="Q5qrw"></a>
## selenium定位的方法有哪些
在 Selenium 中，定位元素是用于在 Web 页面中定位和操作元素的关键步骤。Selenium 提供了多种定位元素的方法，可以根据元素的不同属性和特征来定位元素。以下是常用的几种定位方法：

1. 通过 ID 定位：<br />使用 `find_element_by_id()` 方法根据元素的 ID 属性来定位元素。

```python
element = driver.find_element_by_id("element_id")
```

2. 通过 Name 定位：<br />使用 `find_element_by_name()` 方法根据元素的 Name 属性来定位元素。

```python
element = driver.find_element_by_name("element_name")
```

3. 通过 Class Name 定位：<br />使用 `find_element_by_class_name()` 方法根据元素的 Class Name 属性来定位元素。

```python
element = driver.find_element_by_class_name("element_class")
```

4. 通过 Tag Name 定位：<br />使用 `find_element_by_tag_name()` 方法根据元素的标签名来定位元素。

```python
element = driver.find_element_by_tag_name("tag_name")
```

5. 通过 XPath 定位：<br />使用 `find_element_by_xpath()` 方法根据 XPath 表达式来定位元素。

```python
element = driver.find_element_by_xpath("xpath_expression")
```

6. 通过 CSS Selector 定位：<br />使用 `find_element_by_css_selector()` 方法根据 CSS 选择器来定位元素。

```python
element = driver.find_element_by_css_selector("css_selector")
```

以上是常见的定位元素的方法，除此之外，Selenium 还支持更多的定位方法，如通过链接文本、部分链接文本、标签属性等来定位元素。在使用定位方法时，建议根据元素的具体特征选择合适的定位方法，以确保定位的准确性和稳定性。
<a name="oOZxs"></a>
## selenium 如果页面响应时间过长的话，应该怎么处理（webdriverwait）
当页面响应时间过长时，可以采取以下一些方法来处理：

1. 隐式等待（Implicit Wait）：<br />在创建 WebDriver 实例时，可以设置一个隐式等待时间。这个等待时间会在 WebDriver 在查找元素时进行全局有效，如果找到元素了就会立即执行，如果没有找到元素，它将继续等待一段时间。这样可以等待页面加载完成，从而避免因页面响应时间过长而导致的元素查找失败。

```python
from selenium import webdriver

# 创建 WebDriver 实例，并设置隐式等待时间为 10 秒
driver = webdriver.Chrome()
driver.implicitly_wait(10)

# 在接下来的操作中，WebDriver 会等待 10 秒来查找元素
```

2. 显式等待（Explicit Wait）：<br />使用显式等待可以更加灵活地等待页面元素出现，这样可以在需要等待的具体操作位置设置等待时间，而不是全局等待。`expected_conditions` 模块提供了一系列等待条件，可以根据元素的状态或可见性等等条件来设置等待时间。

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# 创建 WebDriver 实例
driver = webdriver.Chrome()

# 设置显式等待时间为 10 秒
wait = WebDriverWait(driver, 10)

# 等待直到元素出现在页面中
element = wait.until(EC.presence_of_element_located((By.ID, "element_id")))
```

3. 设置页面加载超时时间：<br />在创建 WebDriver 实例时，可以通过 `set_page_load_timeout()` 方法来设置页面加载的超时时间，如果页面在指定时间内没有加载完成，将会抛出 `TimeoutException` 异常。

```python
from selenium import webdriver

# 创建 WebDriver 实例，并设置页面加载超时时间为 30 秒
driver = webdriver.Chrome()
driver.set_page_load_timeout(30)

# 在接下来的操作中，WebDriver 会等待页面加载完成，如果超过 30 秒则抛出 TimeoutException 异常
```

通过合理使用隐式等待、显式等待或设置页面加载超时时间，可以有效地处理页面响应时间过长的情况，从而提高 Selenium 脚本的稳定性和可靠性。
<a name="VJjBP"></a>
## selenium iframe的切换，怎么实现
在 Selenium 中切换到网页中的 iframe（内嵌框架）是一种常见的操作。当网页中包含 iframe 时，需要切换到 iframe 内部才能对其内部的元素进行操作。下面介绍两种常用的切换到 iframe 的方法：

1.  使用 `switch_to.frame()` 方法：<br />`switch_to.frame()` 方法可以通过索引、iframe 元素、iframe 名称或 ID 来切换到指定的 iframe。 
   - 通过索引：<br />如果页面中有多个 iframe，可以使用索引来切换到指定的 iframe。索引从 0 开始，表示第一个 iframe。
```python
from selenium import webdriver

driver = webdriver.Chrome()
driver.get("https://example.com")

# 切换到第一个 iframe
driver.switch_to.frame(0)
```

   - 通过 iframe 元素：<br />如果在代码中已经获取了 iframe 元素，可以直接使用它来切换到该 iframe。
```python
from selenium import webdriver

driver = webdriver.Chrome()
driver.get("https://example.com")

# 获取 iframe 元素
iframe = driver.find_element_by_css_selector("iframe#iframe_id")

# 切换到 iframe
driver.switch_to.frame(iframe)
```

   - 通过 iframe 名称或 ID：<br />如果 iframe 元素有 `name` 或 `id` 属性，可以使用该属性的值来切换到 iframe。
```python
from selenium import webdriver

driver = webdriver.Chrome()
driver.get("https://example.com")

# 切换到名为 "iframe_name" 的 iframe
driver.switch_to.frame("iframe_name")

# 或切换到 ID 为 "iframe_id" 的 iframe
driver.switch_to.frame("iframe_id")
```

2.  使用 `switch_to.default_content()` 方法：<br />当需要从 iframe 中切换回到默认的父级文档时，可以使用 `switch_to.default_content()` 方法。 
```python
from selenium import webdriver

driver = webdriver.Chrome()
driver.get("https://example.com")

# 切换到 iframe
driver.switch_to.frame("iframe_name")

# 在 iframe 中执行操作

# 切换回默认的父级文档
driver.switch_to.default_content()
```
 

使用上述方法可以在 Selenium 中实现在 iframe 和默认文档之间的切换，从而在 iframe 内部进行元素定位和操作。

<a name="ksdkP"></a>
## 为什么选择做测试而不是开发
测试相比开发需要更多的是耐心，细心，交流这种品德，可能说自己有这方面优点所以比起开发更适合测试。
<a name="Czdhv"></a>
## 为什么选择测试开发岗，职业规划是什么？
目前在公司里面做的就差不多是测试开发岗，身边也有可以学习的同事。对我而言，python算是我最熟悉的语言，用python开发工具也是我平时非常喜欢做的事情。我平时自己遇到一些事情也会尝试写脚本解决，我本身就比较喜欢做一些工具开发相关的工作。加上测试的话我感觉其实是整个工业界生产过程中极其重要的一环，其实是担负很多责任的，也有许许多多可以深耕学习的地方吧，目前对未来的打算也是会考虑继续往技术+测试业务两个方向一起深入。<br />职业规划的话，

1. 就先学着写好测试工具的开发，尽可能让代码的效率更高、代码可读性更好，好好沉淀技术。
2. 学习怎么制定测试计划、测试用例、自动化测试流水线搭建之类的测试业务相关的。
3. 有经验的话或许可以在测试岗上小有成就，带带新人什么的。




















